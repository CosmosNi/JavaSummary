{"./":{"url":"./","title":"前言","keywords":"","body":"前言 "},"JDK/BASE.html":{"url":"JDK/BASE.html","title":"java基础总结","keywords":"","body":"java基础总结 1.1 对象的概念 万物皆对象 程序是一组对象，通过信息传递告知彼此该做什么。 每个对象都有自己的存储空间，可容纳其他对象。 每个对象都有一个类型。每个对象都是某个类的实例。 同一类的对象都能接口相同的类型。 1.3 抽象类 抽象方法：只有声明，没有具体的实现。 如果有一个类含有抽象方法，则这个类抽象类，需由abstract修饰。 特点： 抽象方法必须是public或者protected 抽象类不能实例化 如果子类不是不是抽象类，则必须实现父类的抽象方法 1.3 接口 接口中定义的变量被隐式指定为public static final。 接口中所有的方法不能有具体的实现。在java8中，可用default关键字在接口中实现默认方法。 1.4 接口与抽象类的区别 抽象类中的成员变量可以是各种类型的，而接口中的变量是public static final 接口不能有静态代码块以及静态方法，而抽象方法可以 一个类只能实现一个抽象类，但是一个类可以实现多个接口。 抽象类是对事物的抽象，接口是对行为的抽象 1.5 重写equal()方法的注意点 自反性：对于任何非空引用，x.equals(x)应该返回true 对称性：对于任何引用x和y，如果x.equals(y)返回为true，那么y.equals(x)也应该返回true 传递性：对于任何引用，x，y和z，如果x.equals(y)返回为true，那么y.equals(x)也应该返回true 一致性：如果x和y引用的对象没有发生变化，返回调用x.equals(y)应该返回相同的结果 对于任何非空引用x，x.equals(null)应该返回false 1.6 对象序列化 对象序列化是以特殊的文件格式存储对象数据的。 1.7 类的加载 Java默认提供的三个ClassLoader： BootStrap ClassLoader：称为启动类加载器，是Java类加载层次中最顶层的类加载器，负责加载JDK中的核心类库 Extension ClassLoader：称为扩展类加载器，负责加载Java的扩展类库，默认加载JAVA_HOME/jre/lib/ext/目下的所有jar。 App ClassLoader：称为系统类加载器，负责加载应用程序classpath目录下的所有jar和class文件。 ClassLoader使用的是双亲委托模型来搜索类的（避免重复加载），从上至下搜索。每个ClassLoader实例都有一个父类加载器的引用。 JVM在判定两个class是否相同时，不仅要判断两个类名是否相同，而且要判断是否由同一个类加载器实例加载的。 "},"JVM/BASE.html":{"url":"JVM/BASE.html","title":"JVM虚拟机","keywords":"","body":"JVM虚拟机 1.1 程序计数器（线程私有） 当前线程所执行的字节码的行号指示器，每条线程都要有一个独立的程序计数器。（指令的执行都是通过抢占cpu资源的（cpu分配时间片），每个线程可能执行了一段时间后，就被其他线程抢占了资源。所以需要程序计数器来记录当前执行到的行号。） 对于java方法，计数器记录的是虚拟机字节码指令的地址。对于Native方法，则为空。 1.2 虚拟机栈（线程私有） 是描述java方法执行的内存模型。每个方法在执行的同时都会创建一个栈帧，用于存储局部变量表，操作数栈，动态链接，方法出口等信息。每一个方法从调用直至执行完成的过程，就对应一个栈帧在虚拟机栈中入栈到出栈的过程。 栈帧随着方法调用而创建，随着方法结束而销毁。 1.3 本地方法区（线程私有） 类似虚拟机栈。区别在于本地方法栈为Native方法服务。 1.4 堆（运行时数据区，线程共享） 创建的对象和数组都保存在java堆内存中，也是垃圾收集器进行垃圾收集最重要的内存区域。 1.5 方法区/永久代（线程共享） 用于存储JVM加载的类信息， 1.6 垃圾回收算法 标记-清除算法：该算法从每个GC Roots出发，依次标记有引用关系的对象，最后将没有被标记的对象清除。此种算法会带来大量的空间碎片，导致需要一个较大连续空时间时容易触发FullGC。 标记-整理算法：首先从GC Roots出发标记存活的对象，然后将存活对象整理到内存空间的一端，形成连续的已使用空间，最后把已使用空间之外的部门全部清理掉，这样就不会出现空间碎片的问题。 “Mark-Copy”算法：为了能够并行的标记和整理将空间分为两块，每次只激活其中一块，垃圾回收时只需要吧存活的对象复制到另一块未激活空间上，将未激活空间标记为已激活，将已激活空间标记为未激活，然后清除原空间中的原对象。为主流的YGC算法进行新生代的垃圾回收。 1.7 垃圾回收器 serial回收器：主要应用于YGC的垃圾回收器，采用串行单线程的方式完成GC任务。在垃圾回收的某个阶段会暂停整个应用程序的执行。 CMS回收器：回收停顿时间表较短，目前比较常用的垃圾回收器。他通过初始标记、并发标记、重新标记、并发清楚四个步骤完成垃圾回收工作。由于CMS采用的“标记-清除算法”，因此长生大量的空间碎片。为了解决这个问题，CMS可以通过配置-XX:+UseCMSCompactAtFullCollection参数，强制JVM在FGC完成后对老年代进行压缩，执行一次空间碎片整理。为了较少STW次数，CMS也可以通过配置XX:+UseCMSCompactAtFullCollection=n，即在执行n次FGC后，JVM再在老年代执行空间碎片整理。 G1：-XX:+UseG1GC。与CMS相比，G1具备压缩功能，能避免碎片问题。GI 将 Java 堆空间分割成了若干相同大小的 区域，即 region ，包括 Eden 、 Survivor 、 Old 、 Humongous 四种类型。其 其中， Humongous 是特殊的 Old 类型，专门放置大型对象。这样的划分方式意昧着不需要一个连续的内存空间管理对象。 G I 将空间分为多个区域，优先回收垃圾最多的 区域。 GI 采用的是“Mark-copy”，有非常好的空间整合能力，不会产生大量的空间碎片。G I 的一大优势在于可预测的停顿时间，能够尽可能快地在指定时间内完成垃圾回收任务。在 JDKl l 中，已经将 G I 设为默认垃圾回收器 ， 通过 jstat 命令可以查看垃圾回收情况。 "},"THREAD/BASE.html":{"url":"THREAD/BASE.html","title":"并发编程相关知识点","keywords":"","body":"并发编程相关知识点 1.1 线程的状态 New（新创建）：新创建一个新的线程对象对象后，在调用他的start（）方法，系统会为此线程分配CPU资源，使其处于Runnable（可运行状态），这是一个准备运行的阶段。如果线程抢占到CPU资源，此线程就处于Running（运行）状态。 Runnable（可运行） Runnable状态和Running状态可相互切换，因为有可能线程运行一段时间后，有其他高优先级的线程抢占了CPU资源，这时Running状态变成了Runnable状态。 线程进入Runnable状态大体分为如下几种情况： 调用sleep（）方法后经过的时间超过了指定的休眠时间 线程调用的堵塞IO已经返回，堵塞方法执行完毕 线程成功地获取了试图同步的监视器 线程处于等待某个通知，其他线程发出了通知。 处于挂起状态的线程调用了resume回复方法。 Blocked（被堵塞） 例如遇到一个IO操作，此时CPU处于空闲状态，可能会转而把CPU时间片分配给其他的线程，这是也可以成为“暂停”状态。 线程调用sleep（）方法，主动放弃占用的处理器资源。 线程调用了堵塞式IO方法，在该方法返回前，该线程堵塞 线程试图获得一个同步监视器，但该同步监视器正被其他线程所持有。 线程等待某个通知。 程序调用了suspend方法将该线程挂起。此方法容易导致死锁，尽量避免使用该方法。 run（）：运行结束进入销毁阶段，整个线程执行完毕。 join（）：使所属线程对象x正常执行run（）方法中的任务，而使当前线程z无限期堵塞，等待线程x销毁后再继续执行线程z后面的代码。join具有使线程排队运行的作用，有些类似同步的运行效果。join与synchronized的区别是：join在内部使用wait方法进行等待，而synchronized使用的“对象监视器”原理做同步。 Waiting（等待） Timed（waiting） Terminated（被终止） 1.2 指令重排 指令重排是指在程序执行过程中, 为了性能考虑, 编译器和CPU可能会对指令重新排序。 不能重排的指令 程序顺序原则，一个线程内保证语义的串行性。 volatile规则：volitile变量的写先于读发生，这保证了volatile变量的可见性。 锁规则：解锁（unlock）必然发生在随后加锁（lock）前。 传递性：A先于B，B先于A，那么A必然先于B。 线程的start（）方法先于它的每个动作。 线程的所有操作先于线程的终结（Thread.join） 线程的中断（interrupt（））先于被中断线程的代码。 对象的构造函数的执行，结束先于finalize（）方法。 1.3 CAS算法 cas算法过程是：它包含三个参数CAS（V,E,N），其中V表示呀更新的变量，E表示预期值，N表示新值。仅当V值等于E值时，才会将V的值设为N，如果V值和E值不同，说明已经有其他线程做了更新，则当前线程什么都不做。最后，CAS返回当前V的真实值。CAS操作是抱着乐观的态度进行的，它总认为自己可以成功完成操作。当多个线程同时使用CAS操作一个变量时，只有一个会胜出，并成功更新，其余的均会失败。失败的线程不会被挂起，仅是被告知失败，并且允许再次尝试，当然也允许失败的线程放弃操作。 1.4 死锁的概念 死锁的概念 死锁就是两个或者多个线程互相占用对方需要的资源，而都不进行释放，导致彼此之间相互等待对方释放资源，产生了无限制等待的现象。死锁一旦发生，如果没有外力介入，这种等待将永远存在，从而对程序产生严重的影响。 "},"THREAD/JUC.html":{"url":"THREAD/JUC.html","title":"jdk内置JUC组件","keywords":"","body":"jdk内置JUC组件 1.1 Lock相关概念 Lock作用: 锁用来保护代码片段，任何时刻只能有一个线程执行被保护的代码。 锁可以管理试图进入被保护代码段的线程。 锁可以拥有一个或多个相关的条件对象。 每个条件对象管理那些已经进入被保护的代码段但还不能运行的线程。 公平与非公平锁: 公平锁表示线程获取锁的顺序是按照线程加锁的顺序来分配的，即先来先得的FIFO先进先出顺序。而非公平锁是一种获取锁的抢占机制，是随机获得锁的，和公平锁不一样的就是先来的不一定先得到锁，这个方式肯呢过造成某些线程一直拿不到锁，结果也就是不公平的了。 1.2 ReentrantLock (默认非公平锁) 重入锁（ReentrantLock）是一种递归无阻塞的同步机制。 它有一个与锁相关的获取计数器，如果拥有锁的某个线程再次得到锁，那么获取计数器就加1，然后锁需要被释放两次才能获得真正释放。这模仿了 synchronized 的语义；如果线程进入由线程已经拥有的监控器保护的 synchronized 块，就允许线程继续进行，当线程退出第二个（或者后续） synchronized 块的时候，不释放锁，只有线程退出它进入的监控器保护的第一个 synchronized 块时，才释放锁。 常用方法： lock()： 如果该锁没有被另一个线程保持，则获取该锁并立即返回，将锁的保持计数设置为 1。 如果当前线程已经保持该锁，则将保持计数加 1，并且该方法立即返回。 如果该锁被另一个线程保持，则出于线程调度的目的，禁用当前线程，并且在获得锁之前，该线程将一直处于休眠状态，此时锁保持计数被设置为 1 lockInterruptibly() 如果当前线程未被中断，则获取锁。 如果该锁没有被另一个线程保持，则获取该锁并立即返回，将锁的保持计数设置为 1。 如果当前线程已经保持此锁，则将保持计数加 1，并且该方法立即返回。 如果锁被另一个线程保持，则出于线程调度目的，禁用当前线程，并且在发生以下两种情况之一以前，该线程将一直处于休眠状态(锁由当前线程获得；或者 其他某个线程中断当前线程。 ) 如果当前线程获得该锁，则将锁保持计数设置为 1。 此方法是一个显式中断点，所以要优先考虑响应中断，而不是响应锁的普通获取或重入获取。 tryLock():仅在调用时锁未被另一个线程保持的情况下，才获取该锁。 如果该锁没有被另一个线程保持，并且立即返回 true 值，则将锁的保持计数设置为 1。即使已将此锁设置为使用公平排序策略，但是调用 tryLock() 仍将 立即获取锁（如果有可用的），而不管其他线程当前是否正在等待该锁。在某些情况下，此“闯入”行为可能很有用，即使它会打破公平性也如此。如果希望遵守此锁的公平设置，则使用 tryLock(0, TimeUnit.SECONDS) ，它几乎是等效的（也检测中断）。 如果当前线程已经保持此锁，则将保持计数加 1，该方法将返回 true。 如果锁被另一个线程保持，则此方法将立即返回 false 值。 1.3 synchroized 相关定义： 调用关键字synchroized生命的方法一定是排队运行的 避免数据出现交叉的情况，使用synchroized关键词进行同步 关键词synchroized拥有锁重入的功能 ，也就是在使用synchroized时，当一个线程得到一个对象锁后，在此请求此对象锁时是可以再次得到该对象锁的。 当一个线程执行的代码出现异常时，其所持有的锁会自动释放。 同步不可以被继承。 synchroized同步块 锁非this对象相比synchroized（this）更加灵活，当一个方法中有多个同步块时，不用竞争this对象锁。 关于synchroized（非this对象x）的写法是将x对象本身作为\"对象监视器\"，有如下三个结论： 当多个线程同时执行synchroized（X）{}同步代码块时呈同步效果。 当其他线程执行x对象中synchroized同步方法时呈同步效果。 当其他线程执行x对象方法中的synchroized（this）代码块时也呈现同步效果。 如果其他线程调用不加synchroized关键字的方法时，还是异步调用。 synchroized关键字加到非static静态方法是给对象上锁，而教导static方法上则是对Class类加锁。 对于String对象，不要用作对象锁。String a=\"A\",String b=\"A\"，a==b，导致线程会使用同一个对象锁 在设计程序时，要避免双方互相持有对方锁的情况，会导致死锁。 1.4 volitile volitile只保证可见性，不保证原子性。 使用场景： 写入变量时并不依赖变量的当前值。或者能够确定保证只有单一的线程能修改变量的值。 变量不需要与其他状态变量共同参与不变约束。 访问变量的时候，没有其他原因需要加锁。 volatile和synchronized比较 关键字volatile是线程同步的轻量实现，所以volatile性能肯定比synchronized好，并且volatile只能修饰于变量，而synchronized可以修饰方法以及代码块。 多线程访问volatile不会发生堵塞，而synchronized会出现堵塞。 volatile只能保证数据的可见性，但不能保证原子性；而synchronized可以保证原子性，也可间接保证可见性，因为它会将私有内存和公共内存中的数据做同步 volatile解决的是变量在多个线程之间的可见性，而synchronized解决的是多个线程之间访问资源的同步性。 1.5 ThreadLocal Threadlocal提供了get和set的访问器，为每个使用它的线程维护一份单独的拷贝。所以get返回的都是当前线程设置的最新值。 ThreadLocal在内部维护了一个ThreadMap用来映射线程的独有变量。 1.6 Future+callable 所谓异步调用其实就是实现一个可无需等待被调用函数的返回值而让操作继续运行的方法。在 Java 语言中，简单的讲就是另启一个线程来完成调用中的部分计算，使调用继续运行或返回，而不需要等待计算结果。但调用者仍需要取线程的计算结果。 CompletableFuture: supplyAsync：执行一个异步请求，并返回一个future thenApply：对结果应用一个函数 thenCompose：对结果调用函数并执行返回的future handle：处理结果或错误 thenAccept： 类似于 thenApply, 不过结果为 void whenComplete：类似于 handle, 不过结果为 void thenRun：执行 Runnable, 结果为 void thenCombine:执行两个动作并用给定函数组合结果 thenAcceptBoth:与 thenCombine 类似， 不过结果为 void runAfterBoth:两个都完成后执行_able applyToEither:得到其中一个的结果时， 传入给定的函数 acceptEither:与 applyToEither 类似， 不过结果为 void runAfterEither:其中一个完成后执行 runnable static allOf:所有给定的 future 都完成后完成，结果为 void static anyOf:任意给定的 future 完成后则完成，结果为 void 1.7 SynchronousQueue（同步队列） 同步队列是一种将生产者与消费者线程配对的机制。当一个线程调用 SynchronousQueue 的 put 方法时，它会阻塞直到另一个线程调用 take 方法为止， 反之亦然。 与 Exchanger 的情 况不同， 数据仅仅沿一个方向传递，从生产者到消费者。 即使 SynchronousQueue 类实现了 BlockingQueue 接口， 概念上讲， 它依然不是一个队 列。它没有包含任何元素，它的 size 方法总是返回 0。 1.8 堵塞队列 用处： 对于许多线程问题， 可以通过使用一个或多个队列以优雅且安全的方式将其形式化。生产者线程向队列插人元素， 消费者线程则取出它们。使用队列，可以安全地从一个线程向另一个线程传递数据。 常用堵塞队列 ArrayBlockingQueue：构造一个带有指定容量和公平性设置的堵塞队列。该队列用循环数组实现。 LinkedBlockingQueue/LinkedBlockingDeque：构造一个无上限的堵塞队列或双向队列，用链表实现。 DelayQueue：构造一个包含 Delayed 元素的无界的阻塞时间有限的阻塞队列。只有那些延迟已经超过时间的元素可以从队列中移出。 PriorityBlockingQueue：构造一个无边界阻塞优先队列，用堆实现。 ConcurrentLinkedQueue：构造一个可以被多线程安全访问的无边界非阻塞的队列。 ConcurrentSkipListSet：构造一个可以被多线程安全访问的有序集。第一个构造器要求元素实现 Comparable 接口。 1.9 CountDownLatch闭锁 确保一个计算不被执行，直到它需要的资源初始化。 确保一个服务不会开始，直到它依赖的其他服务都已经开始。 等待，直到活动的所有部分都为继续处理做好充分准备。 CountDownLatch是一个灵活的闭锁实现。允许一个或多个线程等待一个事件集的发生。闭锁状态包括一个计数器，初始化为一个整数。 用来表现需要等待的事件数。countDown方法针对计数器做减操作，表示一个事件已经发生了，而await方法等待计数器达到零，此时所有需要等待的事件都已经发生。如果计数器入口时值为非零，await会一直堵塞直到计数器为零，或者等待线程中断以及超时。 1.10 CyclicBarrier同步屏障 类似于闭锁。与闭锁不同之处在于，所有的线程必须同时到达关卡点，才能继续处理。 闭锁等待的是事件；而同步屏障等待的是其他的线程。 常用示例比如：可将一个任务分割成多个子部分，然后再整合。 1.11 Semaphore计数信号量 用来控制能够同时访问某特定资源的活动的数量。 计数信号量可以用来实现资源池或者给一个容器限定边界。 一个Semaphore管理一个有效的许可，许可的除湿量通过构造函数传递给semaphore活动能够获得许可（只要还有剩余许可），并在使用之后释放许可，如果没有可用的许可，则acquire会被堵塞，直到有可用的为止。 常见的信号量使用即数据库连接池。 1.12 Exchanger交换器 当两个线程在同一个数据缓冲区的两个实例上工作的时候， 就可以使用交换器 ( Exchanger) 典型的情况是， 一个线程向缓冲区填人数据， 另一个线程消耗这些数据。当它们都完成以后，相互交换缓冲区。 1.13 线程池相关参数 核心ThreadPoolExecutor参数： corePoolSize：指定线程池中的线程数量 maximumPoolSize：指定了线程池中的最大线程数量。 keepAliveTime：当线程池线程数量超过corePoolSize，多余的空闲线程的存活时间，即超过corePoolSizde的空闲线程，在多长时间内会被销毁。 unit：keepAliveTime的单位 workQueue：任务队列，被提交但未被执行的任务。 threadFactory:线程工厂，用于创建线程，一般用默认的既可 handler：拒绝策略。当任务太多来不及处理，如何拒绝任务。 workQueue说明： 是一个BlockingQueue接口对象。仅用于存放Runnable对象。 直接提交队列：该功能由SynchronousQueue对象提供。SynchronousQueue没有容量，每一个插入操作都要等待一个相应的删除操作，同理删除。如果使用SynchronizeQueue，则提交的任务不会被真实的保存，而总是将新任务提交给线程执行，如果没有空闲的线程，则尝试创建新的线程，如果线程已经达到最大值，则执行拒绝策略。 有界的任务队列：ArrayBlockQueue实现。当有新的任务需要执行，如果线程池的实际线程数小于corePoolSize，则会优先创建新的线程，若大于corePoolSize，则会将新任务加入等待队列，若等待队列已满，无法加入，则在总线程不大于maximumPoolSize的前提下，创建新的线程执行任务。若大于maximumPoolSize，则执行拒绝策略。 无界的任务队列：LinkBlockQueue类实现。与有界队列相比，除非系统资源耗尽，否则无界队列不存在任务入队失败的情况，当有新的任务到来，系统的线程数小于corePoolSize，线程池会生成新的线程执行任务，当系统的线程数达到corePoolSize，就不会继续增加了。若后续仍有新的任务加入，而有没有空闲的线程资源，则任务直接进入队列等待。若任务创建和处理的速度差异很大，无界队列会保持快速增长，直到耗尽系统内存。 优先任务队列：PriorityBlockQueue实现。可以控制任务执行的先后顺序。它是一个特殊的无界队列。 拒绝策略说明：（可扩展RejectedExecutionHandler接口） AbprtPolicy：该策略会直接抛出异常，阻止系统工作 CallRunsPolicy：只要线程池未关闭，该策略直接在调用者线程中，运行当前被丢弃的任务。显然这样做不会真的丢弃任务，但是，任务提交线程的性能极有可能急剧下降。 DiscardOldestPolicy：该策略将丢弃最老的一个请求，也就是即将被执行的一个任务，并尝试再次提交当前任务。 DiscardPolicy：该策略默默丢弃无法处理的任务，不予任何处理。 扩展：ThreadPoolExecutor提供了beforeExecute(),afterExecute和terminated()三个方法用来对线程池进行控制 "},"THREAD/GUVVA.html":{"url":"THREAD/GUVVA.html","title":"guava框架","keywords":"","body":"guava框架 1.1 限流算法 漏桶算法：利用一个缓冲区，当有请求进入系统时，无论请求的速率如何，都先在缓冲区保存，然后以固定的流速流出缓存区进行处理。漏桶算法的特点是无论外部请求压力如何，漏桶算法总以固定的流速处理数据。漏桶的容器和流出速率是该算法的两个重要参数。 令牌桶算法，是一种反向的漏桶算法。在令牌桶算法中，桶中存放的不再是请求，而是令牌，处理程序只有拿到令牌，才能对请求进行处理。如果没有令牌，那么处理程序要么丢弃请求，要么等待可用的令牌。为了限制流速，该算法在每个单位时间产生一定量的令牌存入桶中。（RateLimiter采用的就是此算法）。 "},"THREAD/DISRUPTOR .html":{"url":"THREAD/DISRUPTOR .html","title":"Disruptor框架","keywords":"","body":"Disruptor框架 1.1 消费者模式 Disruptor消费者获取缓冲区数据的几种策略 BlockWaitStrategy：默认策略。使用BlockWaitStrategy和使用BlockQueue是非常类似的。都是用锁和条件进行数据的监控和线程的唤醒。因为涉及到线程的切换，BlockWaitStrategy策略最节省CPU，但是在高并发下他是性能表现最糟糕的一种等待的略。 SleepingWaitStrategy：这种策略对CPU的消耗和BlockWaitStrategy类似。他会在循环中不断等待数据。它会进行自旋等待，如果不成功，则使用Thread.yield()方法让出CPU ,并最终使用LockSupport.parkNanos（1）进行线程休眠，以确保不占用太多的CPU数据。因此，这种策略对于数据处理可能晖产生比较高的平均延时。他适合对延时要求不是特别高的场合，好处是它对生产者线程的影响最小，典型的应用场景是异步日志。 YieldWaitStrategy：个策略用于低延时场合。消费者线程会不断循环监控缓冲区的变化，在循环内部，它会使用Thread.yield（）方法让出CPU给别的线程执行时间。如果你需要一个高性能的系统，并且对延时有较为严格的要求，则可以考虑这种策略。使用这种策略，相当于消费者线程变成了一个内部执行了Thread.yield（）方法的死循环。因此，你最好有多于消费者线程数量的逻辑CPU数量（这里的逻辑CPU指的是“双核四线程”的四线程，否则整个应用程序都会收到影响）。 BusySpinWaitStrategy：消费者线程会尽最大努力疯狂监控缓冲区的变化。因此，它会吃掉所有的CPU资源。只有对延迟非常苛刻的场合可以考虑使用它。因为使用它等于开启了一个死循环监控，所以你的物理CPU数量必须大于消费者的线程数。 "},"java8/BASE.html":{"url":"java8/BASE.html","title":"java8新特性","keywords":"","body":"java8新特性 1.1 lambda 常用函数接口： Predicate T->boolean 接收T类型的对象并返回boolean值 IntPredicate 接收Integer类型对象 LongPredicate 接收Long类型对象 DoublePredicate 接收Double类型对象 Consumer T->void 接收T类型的对象并进行处理 IntConsumer 接收Integer类型对象 LongConsumer 接收Long类型对象 LongConsumer 接收Double类型对象 Function T->R 接收T类型对象，进行处理后变成R类型对象 IntFunction 接收Integer类型对象，进行处理后变成R类型对象 IntToDoubleFunction IntToLongFunction LongFunction LongToDoubleFunction LongToIntFunction DoubleFunction ToIntFunction 接收T类型对象，返回Integer ToDoubleFunction ToLongFunction Supplier ()->T Supplier主要是用来创建对象的。可以将耗时操作放在get里，在程序中，传递是Supplier对象，只有真正调用get方法时才执行运算，这就是所谓的惰性求值。 BooleanSupplier IntSupplier LongSupplier DoubleSupplier UnaryOperator T->T 接收T类型对象，经过处理后返回T类型对象 IntUnaryOperator LongUnaryOperator DoubleUnaryOperator BinaryOperator (T,T)->T 对两个T类型对象进行处理返回T类型对象 IntBinaryOperator LongBinaryOperator DoubleBinaryOperator BiPredicate (L,R)->boolean 对两个不同类型对象进行处理，返回boolean类型 BiConsumer (T,U)->void 对两个对象进行处理 ObjIntConsumer ObjLongConsumer objDoubleConsumer BiFunction (T,U)->R 对T,U两个类型的对象进行处理并返回R类型数据 ToIntBiFunction ToLongBiFunction ToDoubleBiFunction 1.2 Stream 定义：从支持数据处理操作的源生成元素的序列。 详细定义： 元素序列：就像集合一样，流也提供了一个接口，可以访问特定元素类型的一组有序值。集合讲的是数据，流讲的是计算。 源：流会使用一个提供数据的源，如集合，数组或输入/输出资源。 数据处理操作：流的数据处理功能类似于数据库的操作，以及函数式编程语言中的常用操作。流操作可以顺序执行，也可并行执行。 流操作特点： 流水线：很多操作本身会返回一个流，这样多个操作就可以链接起来，形成一个大的流水线。流水线的操作可以看做对数据源进行数据库式查询。 内部迭代：与使用迭代显式迭代的集合不同，流的迭代操作是在背后进行的。 流只能遍历一次。 1.3.2.1 stream常用方法 (数值类型的流：IntStream，LongStream) map：转换流，将一种类型的流转换为另外一种流。 filter：过滤流，过滤流中的元素。 flapMap：拆解流，将流中每一个元素拆解成一个流。 sorted：对流进行排序。 limit:元素不能超过指定长度。短路操作。 distinct:去重。返回一个元素各异（根据流生成的hashcode和equal的方法实现）的的流。 skip(n):返回一个扔掉前n个元素的流。 flatMap:将一个流中的每个值都转换成另一个流，然后将所有的流链接起来成为一个流，见simpleStreamTest2。 anyMatch：流中是否有一个元素能匹配给定的谓词。 allMatch：类似anyMatch，查看流流中元素是否都能匹配给定的谓词。 noneMatch：allMatch相反。 findAny:返回当前元素的任意元素。 findFirst：查找第一个元素。 reduce：数值计算。 "},"SERVLET/BASE.html":{"url":"SERVLET/BASE.html","title":"servlet总结","keywords":"","body":"servlet总结 "},"SPRING/BASE.html":{"url":"SPRING/BASE.html","title":"Spring总结","keywords":"","body":"Spring总结 1.1 核心类DefaultListableBeanFatory DefaultListableBeanFatory是整个bean加载的核心部分，是spring注册及加载bean的默认实现。以下即DefaultListableBeanFatory的组成结构。 AliasRegistry：定义对alias的简单增删改等操作。 SimpleAliasRegister：使用map作为alias的缓存，并对接口AliasRegistry进行实现。 SingletonBeanRegistry：定义对单例的注册及获取。 BeanFactory：定义获取bean及bean的各种属性。 DefaultSingletonBeanRegistry：对接口SingletonBeanRegistry各函数实现。 HierarchicalBeanFactory：继承BeanFactory，在BeanFactory基础上增加对parentFactory的支持。 BeanDefinitionRegistry：定义对BeanDefinition的增删改操作。 FactoryBeanRegistrySupport：在DefaultSingletonBeanRegistry的基础上增加对FactoryBean的特殊处理功能。 ConfigurableBeanFactory：提供配置Facory的各种方法。 ListableBeanFactory：根据各种条件获取bean的配置清单。 AbstractBeanFactory：综合FactoryBeanRegistrySupport和ConfigurableBeanFactory的功能。 AutowireCapableBeanFactory：提供创建bean、自动注入、初始化以及应用bean的后处理器。 AbstractAutowireCapableBeanFactory：综合AbstractBeanFactory并对接口AutowireCapableBeanFactory进行实现。 ConfigurableListableBeanFactory：BeanFactory配置清单，指定忽略类型及接口等。 1.2 XmlBeanDefinitionReader (xml文件的读取) ResourceLoader：定义资源加载器，主要应用于根据给定的资源文件地址返回对应的resource。 BeanDefinitionReader：主要定义资源文件读取并转换为BeanDefinition的各个功能。 EnvironmentCapable：获取Environment方法 DocumentLoader：定义从资源文件加载到转换为Document的功能 AbstractBeanDefinitionReader：对EnvironmentCapable、BeanDefinitionReader的功能进行实现。 BeanDefinitionDocumentReader：定义读取Document并注册BeanDefinition功能。 BeanDefinitionParserDelegate：定义解析Element的各种方法。 1.3 spring对于循环依赖的解决 构造器循环依赖：表示通过构造器注入构成的循环依赖。此依赖是无法解决的，只能抛出BeanCurrentlyInCreationException setter循环依赖：表示通过setter注入方式构成的循环依赖。对于setter注入造成的依赖是通过Spring容器提前暴露刚完成构造注入但未完成其他步骤（如setter注入）的bean来完成的，而且只能解决单例作用域的bean循环依赖。通过提前暴露一个单例工厂方法，从而使其他的bean能引用到该bean。通过“setAllowCircularReferences（false）”来禁用循环依赖 prototype范围的依赖处理：对于“prototype”作用域bean，spring容器无法完成依赖注入，因为spring容器不进行缓存“prototype”作用域的bean，因此无法提前暴露一个创建中的bean。 1.4 spring生命周期 容器启动后，对bean进行初始化。 按照的bean的定义，注入属性 检测该对象是否实现了Aware接口，并将Aware实例注入到bean中 实现BeanPostProcessor接口，进行一些自定义的前置方法处理。 调用自定义的初始化方法。如postConstruct，init-method等等 实现BeanPostProcessor接口，进行一些自定义的后置方法处理。 容器关闭后，如果bean实现了DisposableBean，则会回调该接口的destroy（）方法 通过给destroy-method指定函数，可以在bean销毁前执行指定的逻辑 "},"SPRING/springMVC.html":{"url":"SPRING/springMVC.html","title":"SpringMVC","keywords":"","body":"SpringMVC 1.1 springMVC执行流程 User向服务器发送request,前端控制Servelt DispatcherServlet捕获; DispatcherServlet对请求URL进行解析，调用HandlerMapping获得该Handler配置的所有相关的对象，最后以HandlerExecutionChain对象的形式返回. DispatcherServlet 根据获得的Handler，选择一个合适的HandlerAdapter. 提取Request中的模型数据，填充Handler入参，开始执行Handler（Controller) Handler执行完成后，返回一个ModelAndView对象到DispatcherServlet 根据返回的ModelAndView，选择一个适合的ViewResolver ViewResolver 结合Model和View，来渲染视图 将渲染结果返回给客户端。 "},"NIO/BASE.html":{"url":"NIO/BASE.html","title":"NIO","keywords":"","body":"NIO 1.1 TCP的三次握手，四次挥手 三次握手： 第一次握手(SYN=1, seq=x)，发送完毕后，客户端进入 SYN_SEND 状态 第二次握手(SYN=1, ACK=1, seq=y, ACKnum=x+1)， 发送完毕后，服务器端进入 SYN_RCVD 状态。 第三次握手(ACK=1，ACKnum=y+1)，发送完毕后，客户端进入 ESTABLISHED 状态，当服务器端接收到这个包时，也进入 ESTABLISHED 状态，TCP 握手，即可以开始数据传输。 四次挥手： 第一次挥手(FIN=1，seq=a)，发送完毕后，客户端进入 FIN_WAIT_1 状态 第二次挥手(ACK=1，ACKnum=a+1)，发送完毕后，服务器端进入 CLOSE_WAIT 状态，客户端接收到这个确认包之后，进入 FIN_WAIT_2 状态 第三次挥手(FIN=1，seq=b)，发送完毕后，服务器端进入 LAST_ACK 状态，等待来自客户端的最后一个ACK。 第四次挥手(ACK=1，ACKnum=b+1)，客户端接收到来自服务器端的关闭请求，发送一个确认包，并进入 TIME_WAIT状态，等待了某个固定时间（两个最大段生命周期，2MSL，2 Maximum Segment Lifetime）之后，没有收到服务器端的 ACK ，认为服务器端已经正常关闭连接，于是自己也关闭连接，进入 CLOSED 状态。服务器端接收到这个确认包之后，关闭连接，进入 CLOSED 状态。 "},"ALGORITHM/BASE.html":{"url":"ALGORITHM/BASE.html","title":"算法总结","keywords":"","body":"算法总结 排序方法 时间复杂度 空间复杂度 直接插入排序 O(n2) O(1) 希尔排序 O(n2) O(1) 直接选择排序 O(n2) O(1) 堆排序 O(nlog2n) O(1) 冒泡排序 O(n2) O(1) 快速排序 O(nlog2n) O(nlog2n） 归并排序 O(nlog2n) O(1) 基数排序 O(d(r+n)) O(rd+n) "},"ALGORITHM/BUBBLE.html":{"url":"ALGORITHM/BUBBLE.html","title":"冒泡排序","keywords":"","body":"冒泡排序 "},"ALGORITHM/HEAD.html":{"url":"ALGORITHM/HEAD.html","title":"堆排序","keywords":"","body":"堆排序 "},"ALGORITHM/INSERT.html":{"url":"ALGORITHM/INSERT.html","title":"插入排序","keywords":"","body":"插入排序 "},"ALGORITHM/MERGE.html":{"url":"ALGORITHM/MERGE.html","title":"归并排序","keywords":"","body":"归并排序 "},"ALGORITHM/QUICK.html":{"url":"ALGORITHM/QUICK.html","title":"快速排序","keywords":"","body":"快速排序 "},"ALGORITHM/SELECTION.html":{"url":"ALGORITHM/SELECTION.html","title":"选择排序","keywords":"","body":"选择排序 "},"ALGORITHM/SHEEL.html":{"url":"ALGORITHM/SHEEL.html","title":"希尔排序","keywords":"","body":"希尔排序 "},"DESIGN/BASE.html":{"url":"DESIGN/BASE.html","title":"设计模式","keywords":"","body":"设计模式 "},"DISTRIBUTED/BASE.html":{"url":"DISTRIBUTED/BASE.html","title":"分布式","keywords":"","body":"分布式 分布式系统：是一个硬件或软件分布在不同的网络计算机上，彼此之间只通过消息传递进行通信和协调的系统。 特点： 分布性：分布式系统中的多台计算机都在空间上随意分布。 对等性:分布式系统中的计算机没有主从之分，组成分布式系统的所有计算机节点都是对等的。 并发性：分布式系统的多个节点，可能并发的操作一些共享的数据。 缺乏全局时钟：在分布式系统中，很难定义两个事件究竟谁先谁后，原因就是分布式系统缺乏一个全局的时钟序列控制。 故障总是会发生：组成分布式系统的所有计算机，都有可能发生任何形式的故障。 "},"DISTRIBUTED/ACID.html":{"url":"DISTRIBUTED/ACID.html","title":"分布式事务","keywords":"","body":"分布式事务 1.1 ACID传统数据库 Atomicity原子性：一个事务中所有操作都必须全部完成，要么全部不完成。 Consistency一致性：在事务开始或结束时，数据库应该在一致状态。 Isolation隔离层： 并发的事务是相互隔离的，一个事务的执行不能被其他事务干扰。 Read Uncommitted：允许脏读取。可以读取其他事务未提交的数据。 Read Committed：只允许获取已经被提交的数据。 Repeatable Read：可重复读取。就是保证在事务处理过程中，多次读取同一数据时，其值和事务开始时刻是一致的。可能会出现幻影数据，即在不同时间段读取同一数据项，可能出现不一致的结果。 Serializable：要求所有事务都被串行执行。 Durability. 一旦事务完成，就不能返回。 1.2 CAP理论 Partition tolerance:分区容错。分布式系统在遇到任何网络分区故障的时候，仍然需要能够保证对外提供满足一致性和可用性的服务，除非整个网络环境都发生了故障。 Consistency ：一致性。是指数据在多个副本之间能够保持一致的特性。 Availability ：可用性。系统提供的服务必须一直处于可用的状态，对于用户的每一个操作请求总是能够在有限的时间内返回结果。 在分布式系统中，只可能满足CP或者AP。如果要保证一致性，那么写的操作必然需要加锁，这样就不满足可用性。如果要保证可用性，那么在通信失败的情况下，无法满足一致性。所以在分布式系统下，需要对一致性和可用性进行取舍。 1.3 BASE理论 基本可用（Basically Available）：是指在分布式系统出现故障的时候，允许损失部分可用性，即保证核心可用。（服务降级）。 响应时间上的损失 功能上的损失 软状态（Soft State）：允许系统存在中间状态，该中间状态不会影响系统整体可用性。即允许系统在不同节点的数据副本之间进行同步的过程存在延时。 最终一致性：是指系统中的所有数据副本经过一段时间后，最终能达到一致的状态。 实际工程实践的变种 因果一致性：A更新完数据项通知B，那么B对于该数据项进行更新操作时，必须基于A更新后的最新值。 读己之所写：进程A更新一个数据项后，它总能访问到更新过的最新值。 会话一致性：将系统数据的访问过程框在一个会话中，保证在同一个有效的会话中实现“读己之所写”的一致性。 单调读一致性：一个进程从系统中读取出一个数据项的某个值后，那么系统对于该进程后续的任何数据访问都不应该返回旧的值。 单调写一致性：一个系统需要能够保证来自同一进程的写操作被顺序的执行 1.4 两阶段提交（2pc） 第一阶段：准备阶段。 协调者节点向所有参与者节点询问是否可以执行提交操作(vote)，并开始等待各参与者节点的响应。 参与者节点执行询问发起为止的所有事务操作，并将Undo信息和Redo信息写入日志。（注意：若成功这里其实每个参与者已经执行了事务操作） 各参与者节点响应协调者节点发起的询问。如果参与者节点的事务操作实际执行成功，则它返回一个”同意”消息；如果参与者节点的事务操作实际执行失败，则它返回一个”中止”消息。 第二阶段：提交阶段。 如果协调者收到了参与者的失败消息或者超时，直接给每个参与者发送回滚(Rollback)消息；否则，发送提交(Commit)消息；参与者根据协调者的指令执行提交或者回滚操作，释放所有事务处理过程中使用的锁资源。(注意:必须在最后阶段释放锁资源) 当协调者节点从所有参与者节点获得的相应消息都为”同意”时: 1）协调者节点向所有参与者节点发出”正式提交(commit)”的请求。 2）参与者节点正式完成操作，并释放在整个事务期间内占用的资源。 3）参与者节点向协调者节点发送”完成”消息。 4）协调者节点受到所有参与者节点反馈的”完成”消息后，完成事务。 当任一参与者节点在第一阶段返回的响应消息为”中止”或协调者节点在第一阶段的询问超时之前无法获取所有参与者节点的响应消息时: 1）协调者节点向所有参与者节点发出”回滚操作(rollback)”的请求。 2）参与者节点利用之前写入的Undo信息执行回滚，并释放在整个事务期间内占用的资源。 3）参与者节点向协调者节点发送”回滚完成”消息。 4）协调者节点受到所有参与者节点反馈的”回滚完成”消息后，取消事务。 缺点： 同步阻塞问题。执行过程中，所有参与节点都是事务阻塞型的。当参与者占有公共资源时，其他第三方节点访问公共资源不得不处于阻塞状态。 单点故障。由于协调者的重要性，一旦协调者发生故障。参与者会一直阻塞下去。尤其在第二阶段，协调者发生故障，那么所有的参与者还都处于锁定事务资源的状态中，而无法继续完成事务操作。 数据不一致。在二阶段提交的阶段二中，当协调者向参与者发送commit请求之后，发生了局部网络异常或者在发送commit请求过程中协调者发生了故障，这回导致只有一部分参与者接受到了commit请求。而在这部分参与者接到commit请求之后就会执行commit操作。但是其他部分未接到commit请求的机器则无法执行事务提交。于是整个分布式系统便出现了数据部一致性的现象。 协调者再发出commit消息之后宕机，而唯一接收到这条消息的参与者同时也宕机了。那么即使协调者通过选举协议产生了新的协调者，这条事务的状态也是不确定的，没人知道事务是否被已经提交。 1.5 三阶段提交（3pc） 在二阶段的基础上： 引入超时机制。同时在协调者和参与者中都引入超时机制。 在第一阶段和第二阶段中插入一个准备阶段。保证了在最后提交阶段之前各参与节点的状态是一致的。 CanCommit阶段 协调者向参与者发送commit请求，参与者如果可以提交就返回成功响应，否则返回失败响应。 事务询问 协调者向参与者发送CanCommit请求。询问是否可以执行事务提交操作。然后开始等待参与者的响应。 响应反馈 参与者接到CanCommit请求之后，正常情况下，如果其自身认为可以顺利执行事务，则返回Yes响应，并进入预备状态。否则反馈No。 PreCommit阶段 协调者根据参与者的反应情况来决定是否可以记性事务的PreCommit操作。 发送预提交请求 协调者向参与者发送PreCommit请求，并进入Prepared阶段。 事务预提交 参与者接收到PreCommit请求后，会执行事务操作，并将undo和redo信息记录到事务日志中。 响应反馈 如果参与者成功的执行了事务操作，则返回ACK响应，同时开始等待最终指令。 假如有任何一个参与者向协调者发送了No响应，或者等待超时之后，协调者都没有接到参与者的响应，那么就执行事务的中断。 发送中断请求 协调者向所有参与者发送abort请求。 中断事务 参与者收到来自协调者的abort请求之后（或超时之后，仍未收到协调者的请求），执行事务的中断。 doCommit阶段 执行提交 发送提交请求 协调接收到参与者发送的ACK响应，那么他将从预提交状态进入到提交状态。并向所有参与者发送doCommit请求。 事务提交 参与者接收到doCommit请求之后，执行正式的事务提交。并在完成事务提交之后释放所有事务资源。 响应反馈 事务提交完之后，向协调者发送Ack响应。 完成事务 协调者接收到所有参与者的ack响应之后，完成事务。 中断事务 （协调者没有接收到参与者发送的ACK响应） 发送中断请求 协调者向所有参与者发送abort请求 事务回滚 参与者接收到abort请求之后，利用其在阶段二记录的undo信息来执行事务的回滚操作，并在完成回滚之后释放所有的事务资源。 反馈结果 参与者完成事务回滚之后，向协调者发送ACK消息 中断事务 协调者接收到参与者反馈的ACK消息之后，执行事务的中断 注：在doCommit阶段，如果参与者无法及时接收到来自协调者的doCommit或者rebort请求时，会在等待超时之后，会继续进行事务的提交。 发送提交请求 协调接收到参与者发送的ACK响应，那么他将从预提交状态进入到提交状态。并向所有参与者发送doCommit请求。 事务提交 参与者接收到doCommit请求之后，执行正式的事务提交。并在完成事务提交之后释放所有事务资源。 响应反馈 事务提交完之后，向协调者发送Ack响应。 完成事务 协调者接收到所有参与者的ack响应之后，完成事务。 中断事务 1.发送中断请求 协调者向所有参与者发送abort请求 2.事务回滚 参与者接收到abort请求之后，利用其在阶段二记录的undo信息来执行事务的回滚操作，并在完成回滚之后释放所有的事务资源。 3.反馈结果 参与者完成事务回滚之后，向协调者发送ACK消息 4.中断事务 协调者接收到参与者反馈的ACK消息之后，执行事务的中断。 在doCommit阶段，如果参与者无法及时接收到来自协调者的doCommit或者rebort请求时，会在等待超时之后，会继续进行事务的提交。 1.6 Paxos算法 "},"DISTRIBUTED/zk.html":{"url":"DISTRIBUTED/zk.html","title":"Zookeeper","keywords":"","body":"Zookeeper 1.1 Zookeeper简介 Zookeeper是一个开源的分布式协调服务，是一个典型的分布式数据一致性的解决方案，分布式应用程序可以基于此实现诸如数据发布/订阅，负载均衡，命名服务，分布式协调/通知，集群管理，Matser选举，分布式锁和分布式队列等功能。 1.2 Zk特性 顺序一致性：从同一个客户端发起的事务请求，最终将会严格地按照其发起顺序被应用到Zk中去。 原子性：所有事务请求的处理结果在整个集群中所有机器上的应用情况是一致的，也就是说，要么整个集群的所有机器都成功应用了某个事务，要么都没有应用。 单一视图：无论客户端连接是哪个zk服务器，其看到的服务端数据模型都是一致的。 可靠性：一旦服务端成功应用了一个事务，并完成对客户端的响应，那么该事务所引起的服务端状态变更将会被一直保留下来，除非有另外一个事务对其进行了变更。 实时性：在一定的时间段内，客户端最终一定能够从服务端上读取到最新的数据状态。 1.3 zk集群 zk集群中有三种角色，Leader，Follower，Observer。zk集群中的所有机器通过一个Leader选举过程来选定一台名为”Leader“的机器，Leader服务器为客户端提供读和写服务。Follower，Observer都能提供读服务，区别在于Observer不参加写操作的”过半写成功“策略。因此Observer可以在不影响写性能的情况下提升集群的读性能。 1.4 会话 客户端和服务器之间建立一个TCP长连接，通过这个连接，客户端可以通过心跳检测与服务器保持有效的会话，也能够向服务器端发送请求并接受响应，同时接收来自服务器的Watch事件通知。Session的sessionTimeout值用来设置一个客户端会话的超时时间。在服务器发生故障时，只要在sessionTimeout规定的时间内能够重新连接到集群中的任意一台服务器，那么之前创建的会话仍然有效。 1.5 数据节点（Znode） zk将所有数据都存在内存中，数据模型是一颗树，有斜杠（/）进行分割路径。 在zk中，ZNode分为持久节点和临时节点。所谓持久节点是指一旦这个ZNode被创建了，除非主动进行ZNode的移除操作，否则这个ZNode将一直保存在zk上。 临时节点，生命周期与客户端会话绑定，一旦客户端会话失效，那么这个客户端创建的所有临时节点都会被移除。zk还允许用户为每个节点添加一个特殊的属性：SEQUENTIAL。一旦节点被标记这个属性，那么这个节点在创建的时候，zk会自动在其节点后面追加一个整形数字，这个整形数字是一个由父节点维护的自增数字。 1.6 Watch zk允许用户在指定节点上注册一些watch，并且在一些特定事件触发的时候，zk会将事件通知到感兴趣的客户端上去，该机制是zk实现分布式协调服务的重要特性。 1.7 权限 CREATE：创建子节点的权限。 READ：获取节点数据好子节点列表的权限。 WRITE：更新节点数据的权限。 DELETE：删除子节点的权限。 ADMIN：设置节点的ACL权限 1.8 ZAB协议 定义：所有事务请求必须由一个全局唯一的服务器来协调处理，这样的服务器称为Leader服务器，而余下的其他服务器都是Follower服务器。LEADER服务器负责将一个客户端请求转换成一个事务Proposal（提案），并将该Proposal分发个集群中所有Follower服务器。之后Leader服务器需要等待所有Follower的反馈，一旦超过半数的Follower服务器进行正确的反馈后，那么Leader就会再次向所有的Follower服务器分发Commit消息，要求将Proposal进行提交。 崩溃恢复：当Leader服务器出现故障的时候，ZAB协议就会进入恢复模式并选举新的Leader服务器。当选举产生新的Leader服务器后，同时集群中已经有过半机器与该Leader服务器完成了状态同步后，ZAB协议就会退出恢复模式。当遵守ZAB协议的服务器新加入时，会自动进入恢复模式，与Leader服务器进行数据同步。 ZAB协议需要确保那些已经在Leader服务器上提交的事务最终被所有服务器都提交。 ZAB协议需要确保丢弃那些只在Leader服务器上被提出的事务。 为了满足以上两种情况，ZAB协议设计了如下的Leader选举算法：保证新选举出来的Leader服务器拥有集群中所有机器最高编号（即ZXID最大）的事务Proposal，那么就可以保证新选举出来的Leader一定具有所有已经提交的提案。 消息广播：Leader服务器在接收到客户端的事务请求后，会生成对应事务提案并发起一轮广播协议；而如果集群中其他机器接收到客户端的事务请求，那么这些非Leader服务器会首先将这个事务请求转发给Leader服务器。在整个消息广播过程中，Leader服务器会为每个事务请求生成对应的Proposal来进行广播,并且在广播Proposal之前，Leader会为这个事务Proposal分配一个全局单调递增的唯一ID，我们称为事务ID（即ZXID）。由于ZAB协议需要保证每一个消息严格的因果关系，因此必须将每一个事务Proposal按照其ZXID的先后顺序进行排序与处理。 在广播过程中，Leader服务器会为每一个Follower服务器分配一个单独的队列，然后将需要广播的事务Proposal依次放入到这个队列中去，并且根据FIFO策略进行消息发送。每一个Follower服务器接收到Proposal后，都会首先将其以事务日志的形式写入到本地磁盘中去，并且在成功写入后反馈给Leader服务器一个Ack响应。当Leader服务器收到超过半数Follower的Ack响应后，就会广播一个Commit消息给所有的Follower服务器以通知其进行事务提交，同时Leader也会完成对事务的提交。 ZXID是一个64位的数字，其中低32位可以看做一个简单的单调递增的计数器，Leader在产生一个新的事务Proposal的时候，都会对计数器加1。而高32位代表Leader周期的epoch的编号。每当选举产生一个新的Leader服务器，都会从这个Leader服务器上取出其本地日志最大事务的Proposal的ZXID，并从该ZXID解析出对应的epoch值，然后对其进行加1操作，并以此作为新的epoch，并将低32位位置0来开始生成新的ZXID。 1.8 ZAB与Paxos算法的区别联系 相同点： 两个都存在一个类似Leader进程的角色，由其负责协调多个follower进程的运行。 Leader进程都会等待超过半数的Follower做出正确的反馈后，才会将一个提案进行提交 在ZAB协议中，每个Proposal中都包含一个epoch值，用来代表当前的Leader周期，在Proxs算法中，同样存在这样一个标识，Ballot。 不同点： 在Paxos算法中，一个新选举的主进程会进行两个阶段的工作。第一阶段被称为读阶段，在这个阶段中，这个新的主进程会通过和其它进程进行通信的方式来收集上一个主进程提出的方案，并将它们提交。第二阶段被称为写阶段，在这个阶段中，当前主进程开始提出它自己的提案。 ZAB协议在paxos的基础上，增加了一个同步的阶段。再同步阶段之前，ZAB协议也存在一个和Paxos算法中的读阶段类似的过程，称为发现阶段。在同步阶段，新的Leader会确保存在过半的Follower已经提交了之前Leader周期中的所有事务Proposal。这一同步阶段的引入，能够有效地保证Leader在新的周期提出事务Proposal之前，所有的进程都已经完成了对之前所有事务Proposal的提交。一旦完成同步阶段，那么ZAB就会执行和Paxos算法类似的些阶段。 ZAB主要用于构建一个高可用的分布式数据主备系统。 Paxos主要用于构建一个分布式的一致性状态机系统。 1.9 zk的典型应用场景 发布/订阅 负载均衡 命名服务 分布式协调/通知 集群管理 Master选举 分布式锁 分布式队列 2.0 Znode类型 持久节点：数据节点从创建后一直存在于zk服务器上，直到有删除操作。 持久顺序节点：每一个父节点都会为它的第一级节点维护一份顺序，用于记录每个 子节点的先后顺序。 临时节点：生命周期和客户端的会话绑在一起。客户端会话失效，节点自动清理。 临时顺序节点： 2.1 状态STAT 数据节点的状态信息 状态属性 说明 czxid 数据节点创建时的事务id mzxid 节点最后一次被更新时的事务id ctime 创建时间 mtime 更新时间 version 数据节点的版本号 cversion 子节点的版本号 aversion 节点的ACL版本号 ephemeralowner 创建该临时节点的会话的sessionId。如果是持久节点，则0 dataLength 数据内容的长度 numChildren 当前节点的子节点个数 pzxid 该节点的子节点列表最后一次被修改时的事务id 2.2 watcher通知状态 KeeperState EventType 触发条件 说明 SyncConnected（3） None（-1） 客户端与服务器成功建立会话 与服务器处于连接状态 SyncConnected（3） NodeCreate Watcher监听的对应数据节点被创建 SyncConnected（3） NodeDeleted watcher监听的对应数据节点被删除 SyncConnected（3） NodeDataChanged Watcher监听的对应数据节点的数据内容发生变更 SyncConnected（3） NodeChildrenChanged Watcher监听的对应数据节点的数据内容发生变更 Disconnected（0） None（-1） 客户端和服务器断开连接 Expired（-112） None（-1） 会话超时 SessionExpiredException异常 AuthFailed（4） None（-1） 通常两种情况 ：使用错误的scheme进行权限检查，SASL权限检查失败 AuthFailedException watcher的特性 一次性：无论客户端还是服务端，一旦一个Watcher被触发，Zookeeper都会将其从对应的存储中移除。所以在使用watcher的时候需要反复注册。这样的设计有效减轻了服务器的压力。 客户端串行执行：客户端watcher回调的过程是一个串行同步的过程。 轻量：watchedEvent是zk整个watcher通知机制的最小通知单元，这个数据结构只包含三部分：通知状态，事件类型和节点路径。也就是说，watcher的通知非常简单，只会告诉客户端发生了事件，而不会说明事件的具体内容。 2.3 ACL--保障数据的安全 ACL机制：权限模式（scheme），授权对象（ID）和权限（Permission），通常使用“schema：id:permission”来标识一个有效的ACL信息。 2.3.1 权限模式：scheme IP：IP模式通过IP地址粒度来进行权限控制。 Digest：“username：password”形式的权限标识来进行权限配置，便于区分不同应用来进行权限控制 world：最开放的权限控制模式。数据节点的访问权限对所有用户开放，所有用户都可以在不进行任何权限校验的情况下操作zk上的数据。特殊的Digest模式，权限标识：“world：anyone” Super：超级用户，也是一种特殊的Digest模式。在super模式下，超级用户可以对任意zk上的数据节点进行任何操作。 2.3.2授权对象：ID 授权对象指的是权限赋予的用户或一个制定实体，例如IP地址或是机器。 2.3.3 权限：Permission 权限是指那些通过权限检查后可以被允许执行的操作。 CREATE（C）：数据节点的创建权限，允许授权对象在该数据节点下创建子节点。 DELETE（D）：子节点的删除权限。 READ（R）：数据节点的读取权限 WRITE（W）：数据节点的读取权限 ADMIN（A）：数据节点的管理权限，允许授权对象对该数据节点进行ACL相关的设置操作。 "},"DISTRIBUTED/redis.html":{"url":"DISTRIBUTED/redis.html","title":"redis","keywords":"","body":"redis 1.1 redis的持久化方式 RDB：在指定的时间间隔对数据进行快照存储。Redis可以通过创建快照来获取存储在内存中的数据在某个时间点上的副本。redis创建快照之后，可以对快照进行备份，可以将快照复制到其他服务器从而创建相同数据的服务器副本。 AOF：记录每次对服务器写的操作,当服务器重启的时候会重新执行这些命令来恢复原始的数据。 1.2 线程模型 redis内部使用文件事件处理器，这个文件处理器是单线程的，所以redis才叫做单线程的模型。他采用IO多路复用机制同时监听多个socket，根据socket上的事件；来选择对应的事件处理器进行处理。 文件处理器包含四个结构：多个socket，IO多路复用程序，文件事件分派器，事件处理器（连接应答处理器，命令请求处理器，命令回复处理器）。 1.3 redis过期两种删除方式 定时删除：redis默认每隔100ms就随机抽取一些设置了过期时间的key，检查其是否过期，如果过期就删除 惰性删除：定期删除可能会导致很多过期的key到了时间并没有删除掉。加入你的过期key，考定期删除没有被删除掉，还停留在内存中，除非你的系统去查一下那个key，才会被redis给删除。 1.4 redis的内存淘汰机制 volatile-lru：从以设置过期时间的数据集中挑选最近最少使用的数据淘汰。 volatile-ttl：从已设置过期时间的数据集中挑选将要过期的数据淘汰 volatile-random：从已设置过期时间的数据集中任意选择数据淘汰 allkeys-lru：当内存不足以容纳新写入数据时，在键空间中，移除最近最少使用的key allkeys-random：从数据集中任意选择数据淘汰 no-eviction：禁止驱逐数据，也就是说当内存不足以容纳新写入数据时，新写入操作会报错 volatile-lfu：从已设置过期时间的数据集中挑选最不经常使用的数据淘汰 allkeys-lfu：当内存不足以容纳新写入数据时，在键空间中，移除最不经常使用的key 1.5 redis产生的相关问题 缓存穿透：是指查询一个数据库一定不存在的数据。正常的使用缓存的流程大致时，数据查询先进行缓存查询，如果key不存在或key已经失效，在对数据库进行查询，并把查询的对象，放入缓存。如果数据库查询对象为空，则不放进缓存。解决方案，对空值也做缓存，缓存周期设置较短一些。或此采用布隆过滤器，将所有可能存在的数据哈希到一个足够大的bitmap中。 缓存雪崩：是指在某一个时间段，缓存集中过期失效。解决方案，根据不同情况，缓存不同周期。用锁/分布式锁或者队列串行访问。 事前:尽量保证整个redis集群的高可用性，发现机器宕机尽快补上。选择合适的内存淘汰策略。 事中：本地ehcache缓存+hystrix限流&降级，避免Mysql崩掉 事后：利用redis持久化机制保存的数据尽快回复缓存 缓存击穿：是指一个key非常热点，大并发集中对这个点进行访问，当这个key在失效的瞬间，持续的大并发就穿破缓存，直接请求数据库。解决方案，使用锁，单机用synchronized,lock等，分布式用分布式锁。缓存过期时间不设置，而是设置在key对应的value里。如果检测到存的时间超过过期时间则异步更新缓存。在value设置一个比过期时间t0小的过期时间值t1，当t1过期的时候，延长t1并做更新缓存操作。 1.6 如何保证缓存与数据库双写时的数据一致性 读的时候，先读缓存，缓存没有的话，在读数据库，然后取出数据放入缓存，同时返回响应。 更新的时候，先删除缓存，在更新数据库。 数据库与缓存更新与读取操作进行异步串行化： ①更新数据的时候，根据数据的唯一标识，将操作路由之后，发送到一个jvm内部的队列里面去。 ②读取数据的时候，如果发现缓存中没有，那么将从数据库读取数据的操作和更新缓存的操作一起路由到同一个JVM内部的队列中去。 ③一个队列对应一个工作线程，然后线程从队列里面去取请求进行操作。 "},"CONTAINER/BASE.html":{"url":"CONTAINER/BASE.html","title":"LINUX+DOCKER","keywords":"","body":"LINUX+DOCKER "},"appendix/base.html":{"url":"appendix/base.html","title":"附录","keywords":"","body":"附录 "},"appendix/idea.html":{"url":"appendix/idea.html","title":"idea快捷键大全","keywords":"","body":"idea快捷键大全 常用快捷键 Ctrl+Shift + Enter，语句完成 “！”，否定完成，输入表达式时按 “！”键 Ctrl+E，最近的文件 Ctrl+Shift+E，最近更改的文件 Shift+Click，可以关闭文件 Ctrl+[ OR ]，可以跑到大括号的开头与结尾 Ctrl+F12，可以显示当前文件的结构 Ctrl+F7，可以查询当前元素在当前文件中的引用，然后按 F3 可以选择 Ctrl+N，可以快速打开类 Ctrl+Shift+N，可以快速打开文件 Alt+Q，可以看到当前方法的声明 Ctrl+P，可以显示参数信息 Ctrl+Shift+Insert，可以选择剪贴板内容并插入 Alt+Insert，可以生成构造器/Getter/Setter等 Ctrl+Alt+V，可以引入变量。例如：new String(); 自动导入变量定义 Ctrl+Alt+T，可以把代码包在一个块内，例如：try/catch Ctrl+Enter，导入包，自动修正 Ctrl+Alt+L，格式化代码 Ctrl+Alt+I，将选中的代码进行自动缩进编排，这个功能在编辑 JSP 文件时也可以工作 Ctrl+Alt+O，优化导入的类和包 Ctrl+R，替换文本 Ctrl+F，查找文本 Ctrl+Shift+Space，自动补全代码 Ctrl+空格，代码提示（与系统输入法快捷键冲突） Ctrl+Shift+Alt+N，查找类中的方法或变量 Alt+Shift+C，最近的更改 Alt+Shift+Up/Down，上/下移一行 Shift+F6，重构 – 重命名 Ctrl+X，删除行 Ctrl+D，复制行 Ctrl+/或Ctrl+Shift+/，注释（//或者/**/） Ctrl+J，自动代码（例如：serr） Ctrl+Alt+J，用动态模板环绕 Ctrl+H，显示类结构图（类的继承层次） Ctrl+Q，显示注释文档 Alt+F1，查找代码所在位置 Alt+1，快速打开或隐藏工程面板 Ctrl+Alt+left/right，返回至上次浏览的位置 Alt+left/right，切换代码视图 Alt+Up/Down，在方法间快速移动定位 Ctrl+Shift+Up/Down，向上/下移动语句 F2 或 Shift+F2，高亮错误或警告快速定位 Tab，代码标签输入完成后，按 Tab，生成代码 Ctrl+Shift+F7，高亮显示所有该文本，按 Esc 高亮消失 Alt+F3，逐个往下查找相同文本，并高亮显示 Ctrl+Up/Down，光标中转到第一行或最后一行下 Ctrl+B/Ctrl+Click，快速打开光标处的类或方法（跳转到定义处） Ctrl+Alt+B，跳转到方法实现处 Ctrl+Shift+Backspace，跳转到上次编辑的地方 Ctrl+O，重写方法 Ctrl+Alt+Space，类名自动完成 Ctrl+Alt+Up/Down，快速跳转搜索结果 Ctrl+Shift+J，整合两行 Alt+F8，计算变量值 Ctrl+Shift+V，可以将最近使用的剪贴板内容选择插入到文本 Ctrl+Alt+Shift+V，简单粘贴 Shift+Esc，不仅可以把焦点移到编辑器上，而且还可以隐藏当前（或最后活动的）工具窗口 F12，把焦点从编辑器移到最近使用的工具窗口 Shift+F1，要打开编辑器光标字符处使用的类或者方法 Java 文档的浏览器 Ctrl+W，可以选择单词继而语句继而行继而函数 Ctrl+Shift+W，取消选择光标所在词 Alt+F7，查找整个工程中使用地某一个类、方法或者变量的位置 Ctrl+I，实现方法 Ctrl+Shift+U，大小写转化 Ctrl+Y，删除当前行 Shift+Enter，向下插入新行 psvm/sout，main/System.out.println(); Ctrl+J，查看更多 Ctrl+Shift+F，全局查找 Ctrl+F，查找/Shift+F3，向上查找/F3，向下查找 Ctrl+Shift+S，高级搜索 Ctrl+U，转到父类 Ctrl+Alt+S，打开设置对话框 Alt+Shift+Inert，开启/关闭列选择模式 Ctrl+Alt+Shift+S，打开当前项目/模块属性 Ctrl+G，定位行 Alt+Home，跳转到导航栏 Ctrl+Enter，上插一行 Ctrl+Backspace，按单词删除 Ctrl+”+/-”，当前方法展开、折叠 Ctrl+Shift+”+/-”，全部展开、折叠 【调试部分、编译】 Alt+Shift+F9，选择 Debug Ctrl+F2，停止 Alt+Shift+F10，选择 Run Ctrl+Shift+F9，编译 Ctrl+Shift+F10，运行 Ctrl+Shift+F8，查看断点 F8，步过 F7，步入 Shift+F7，智能步入 Shift+F8，步出 Alt+Shift+F8，强制步过 Alt+Shift+F7，强制步入 Alt+F9，运行至光标处 Ctrl+Alt+F9，强制运行至光标处 F9，恢复程序 Alt+F10，定位到断点 Ctrl+F8，切换行断点 Ctrl+F9，生成项目 Alt+1，项目 Alt+2，收藏 Alt+6，TODO Alt+7，结构 Ctrl+Shift+C，复制路径 Ctrl+Alt+Shift+C，复制引用，必须选择类名 Ctrl+Alt+Y，同步 Ctrl+~，快速切换方案（界面外观、代码风格、快捷键映射等菜单） Shift+F12，还原默认布局 Ctrl+Shift+F12，隐藏/恢复所有窗口 Ctrl+F4，关闭 Ctrl+Shift+F4，关闭活动选项卡 Ctrl+Tab，转到下一个拆分器 Ctrl+Shift+Tab，转到上一个拆分器 【重构】 Ctrl+Alt+Shift+T，弹出重构菜单 Shift+F6，重命名 F6，移动 F5，复制 Alt+Delete，安全删除 Ctrl+Alt+N，内联 【查找】 Ctrl+R，替换 Ctrl+F，查找 F3，查找下一个 Shift+F3，查找上一个 Ctrl+Shift+F，在路径中查找 Ctrl+Shift+R，在路径中替换 Ctrl+Shift+S，搜索结构 Ctrl+Shift+M，替换结构 Alt+F7，查找用法 Ctrl+Alt+F7，显示用法 Ctrl+F7，在文件中查找用法 Ctrl+Shift+F7，在文件中高亮显示用法 "}}