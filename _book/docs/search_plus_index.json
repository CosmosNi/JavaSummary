{"./":{"url":"./","title":"前言","keywords":"","body":"前言 "},"JDK/BASE.html":{"url":"JDK/BASE.html","title":"java基础总结","keywords":"","body":"java基础总结 1.1 对象的概念 万物皆对象 程序是一组对象，通过信息传递告知彼此该做什么。 每个对象都有自己的存储空间，可容纳其他对象。 每个对象都有一个类型。每个对象都是某个类的实例。 同一类的对象都能接口相同的类型。 1.3 抽象类 抽象方法：只有声明，没有具体的实现。 如果有一个类含有抽象方法，则这个类抽象类，需由abstract修饰。 特点： 抽象方法必须是public或者protected 抽象类不能实例化 如果子类不是不是抽象类，则必须实现父类的抽象方法 1.3 接口 接口中定义的变量被隐式指定为public static final。 接口中所有的方法不能有具体的实现。在java8中，可用default关键字在接口中实现默认方法。 1.4 接口与抽象类的区别 抽象类中的成员变量可以是各种类型的，而接口中的变量是public static final 接口不能有静态代码块以及静态方法，而抽象方法可以 一个类只能实现一个抽象类，但是一个类可以实现多个接口。 抽象类是对事物的抽象，接口是对行为的抽象 1.5 重写equal()方法的注意点 自反性：对于任何非空引用，x.equals(x)应该返回true 对称性：对于任何引用x和y，如果x.equals(y)返回为true，那么y.equals(x)也应该返回true 传递性：对于任何引用，x，y和z，如果x.equals(y)返回为true，那么y.equals(x)也应该返回true 一致性：如果x和y引用的对象没有发生变化，返回调用x.equals(y)应该返回相同的结果 对于任何非空引用x，x.equals(null)应该返回false 1.6 对象序列化 对象序列化是以特殊的文件格式存储对象数据的。 1.7 类的加载 Java默认提供的三个ClassLoader： BootStrap ClassLoader：称为启动类加载器，是Java类加载层次中最顶层的类加载器，负责加载JDK中的核心类库 Extension ClassLoader：称为扩展类加载器，负责加载Java的扩展类库，默认加载JAVA_HOME/jre/lib/ext/目下的所有jar。 App ClassLoader：称为系统类加载器，负责加载应用程序classpath目录下的所有jar和class文件。 ClassLoader使用的是双亲委托模型来搜索类的（避免重复加载），从上至下搜索。每个ClassLoader实例都有一个父类加载器的引用。 JVM在判定两个class是否相同时，不仅要判断两个类名是否相同，而且要判断是否由同一个类加载器实例加载的。 "},"JVM/BASE.html":{"url":"JVM/BASE.html","title":"JVM虚拟机","keywords":"","body":"JVM虚拟机 "},"THREAD/BASE.html":{"url":"THREAD/BASE.html","title":"并发编程相关知识点","keywords":"","body":"并发编程相关知识点 1.1 线程的状态 New（新创建）：新创建一个新的线程对象对象后，在调用他的start（）方法，系统会为此线程分配CPU资源，使其处于Runnable（可运行状态），这是一个准备运行的阶段。如果线程抢占到CPU资源，此线程就处于Running（运行）状态。 Runnable（可运行） Runnable状态和Running状态可相互切换，因为有可能线程运行一段时间后，有其他高优先级的线程抢占了CPU资源，这时Running状态变成了Runnable状态。 线程进入Runnable状态大体分为如下几种情况： 调用sleep（）方法后经过的时间超过了指定的休眠时间 线程调用的堵塞IO已经返回，堵塞方法执行完毕 线程成功地获取了试图同步的监视器 线程处于等待某个通知，其他线程发出了通知。 处于挂起状态的线程调用了resume回复方法。 Blocked（被堵塞） 例如遇到一个IO操作，此时CPU处于空闲状态，可能会转而把CPU时间片分配给其他的线程，这是也可以成为“暂停”状态。 线程调用sleep（）方法，主动放弃占用的处理器资源。 线程调用了堵塞式IO方法，在该方法返回前，该线程堵塞 线程试图获得一个同步监视器，但该同步监视器正被其他线程所持有。 线程等待某个通知。 程序调用了suspend方法将该线程挂起。此方法容易导致死锁，尽量避免使用该方法。 run（）：运行结束进入销毁阶段，整个线程执行完毕。 join（）：使所属线程对象x正常执行run（）方法中的任务，而使当前线程z无限期堵塞，等待线程x销毁后再继续执行线程z后面的代码。join具有使线程排队运行的作用，有些类似同步的运行效果。join与synchronized的区别是：join在内部使用wait方法进行等待，而synchronized使用的“对象监视器”原理做同步。 Waiting（等待） Timed（waiting） Terminated（被终止） 1.2 指令重排 指令重排是指在程序执行过程中, 为了性能考虑, 编译器和CPU可能会对指令重新排序。 不能重排的指令 程序顺序原则，一个线程内保证语义的串行性。 volatile规则：volitile变量的写先于读发生，这保证了volatile变量的可见性。 锁规则：解锁（unlock）必然发生在随后加锁（lock）前。 传递性：A先于B，B先于A，那么A必然先于B。 线程的start（）方法先于它的每个动作。 线程的所有操作先于线程的终结（Thread.join） 线程的中断（interrupt（））先于被中断线程的代码。 对象的构造函数的执行，结束先于finalize（）方法。 1.3 CAS算法 cas算法过程是：它包含三个参数CAS（V,E,N），其中V表示呀更新的变量，E表示预期值，N表示新值。仅当V值等于E值时，才会将V的值设为N，如果V值和E值不同，说明已经有其他线程做了更新，则当前线程什么都不做。最后，CAS返回当前V的真实值。CAS操作是抱着乐观的态度进行的，它总认为自己可以成功完成操作。当多个线程同时使用CAS操作一个变量时，只有一个会胜出，并成功更新，其余的均会失败。失败的线程不会被挂起，仅是被告知失败，并且允许再次尝试，当然也允许失败的线程放弃操作。 1.4 死锁的概念 死锁的概念 死锁就是两个或者多个线程互相占用对方需要的资源，而都不进行释放，导致彼此之间相互等待对方释放资源，产生了无限制等待的现象。死锁一旦发生，如果没有外力介入，这种等待将永远存在，从而对程序产生严重的影响。 "},"THREAD/JUC.html":{"url":"THREAD/JUC.html","title":"jdk内置JUC组件","keywords":"","body":"jdk内置JUC组件 1.1 Lock相关概念 Lock作用: 锁用来保护代码片段，任何时刻只能有一个线程执行被保护的代码。 锁可以管理试图进入被保护代码段的线程。 锁可以拥有一个或多个相关的条件对象。 每个条件对象管理那些已经进入被保护的代码段但还不能运行的线程。 公平与非公平锁: 公平锁表示线程获取锁的顺序是按照线程加锁的顺序来分配的，即先来先得的FIFO先进先出顺序。而非公平锁是一种获取锁的抢占机制，是随机获得锁的，和公平锁不一样的就是先来的不一定先得到锁，这个方式肯呢过造成某些线程一直拿不到锁，结果也就是不公平的了。 1.2 ReentrantLock (默认非公平锁) 重入锁（ReentrantLock）是一种递归无阻塞的同步机制。 它有一个与锁相关的获取计数器，如果拥有锁的某个线程再次得到锁，那么获取计数器就加1，然后锁需要被释放两次才能获得真正释放。这模仿了 synchronized 的语义；如果线程进入由线程已经拥有的监控器保护的 synchronized 块，就允许线程继续进行，当线程退出第二个（或者后续） synchronized 块的时候，不释放锁，只有线程退出它进入的监控器保护的第一个 synchronized 块时，才释放锁。 常用方法： lock()： 如果该锁没有被另一个线程保持，则获取该锁并立即返回，将锁的保持计数设置为 1。 如果当前线程已经保持该锁，则将保持计数加 1，并且该方法立即返回。 如果该锁被另一个线程保持，则出于线程调度的目的，禁用当前线程，并且在获得锁之前，该线程将一直处于休眠状态，此时锁保持计数被设置为 1 lockInterruptibly() 如果当前线程未被中断，则获取锁。 如果该锁没有被另一个线程保持，则获取该锁并立即返回，将锁的保持计数设置为 1。 如果当前线程已经保持此锁，则将保持计数加 1，并且该方法立即返回。 如果锁被另一个线程保持，则出于线程调度目的，禁用当前线程，并且在发生以下两种情况之一以前，该线程将一直处于休眠状态(锁由当前线程获得；或者 其他某个线程中断当前线程。 ) 如果当前线程获得该锁，则将锁保持计数设置为 1。 此方法是一个显式中断点，所以要优先考虑响应中断，而不是响应锁的普通获取或重入获取。 tryLock():仅在调用时锁未被另一个线程保持的情况下，才获取该锁。 如果该锁没有被另一个线程保持，并且立即返回 true 值，则将锁的保持计数设置为 1。即使已将此锁设置为使用公平排序策略，但是调用 tryLock() 仍将 立即获取锁（如果有可用的），而不管其他线程当前是否正在等待该锁。在某些情况下，此“闯入”行为可能很有用，即使它会打破公平性也如此。如果希望遵守此锁的公平设置，则使用 tryLock(0, TimeUnit.SECONDS) ，它几乎是等效的（也检测中断）。 如果当前线程已经保持此锁，则将保持计数加 1，该方法将返回 true。 如果锁被另一个线程保持，则此方法将立即返回 false 值。 1.3 synchroized 相关定义： 调用关键字synchroized生命的方法一定是排队运行的 避免数据出现交叉的情况，使用synchroized关键词进行同步 关键词synchroized拥有锁重入的功能 ，也就是在使用synchroized时，当一个线程得到一个对象锁后，在此请求此对象锁时是可以再次得到该对象锁的。 当一个线程执行的代码出现异常时，其所持有的锁会自动释放。 同步不可以被继承。 synchroized同步块 锁非this对象相比synchroized（this）更加灵活，当一个方法中有多个同步块时，不用竞争this对象锁。 关于synchroized（非this对象x）的写法是将x对象本身作为\"对象监视器\"，有如下三个结论： 当多个线程同时执行synchroized（X）{}同步代码块时呈同步效果。 当其他线程执行x对象中synchroized同步方法时呈同步效果。 当其他线程执行x对象方法中的synchroized（this）代码块时也呈现同步效果。 如果其他线程调用不加synchroized关键字的方法时，还是异步调用。 synchroized关键字加到非static静态方法是给对象上锁，而教导static方法上则是对Class类加锁。 对于String对象，不要用作对象锁。String a=\"A\",String b=\"A\"，a==b，导致线程会使用同一个对象锁 在设计程序时，要避免双方互相持有对方锁的情况，会导致死锁。 1.4 volitile volitile只保证可见性，不保证原子性。 使用场景： 写入变量时并不依赖变量的当前值。或者能够确定保证只有单一的线程能修改变量的值。 变量不需要与其他状态变量共同参与不变约束。 访问变量的时候，没有其他原因需要加锁。 volatile和synchronized比较 关键字volatile是线程同步的轻量实现，所以volatile性能肯定比synchronized好，并且volatile只能修饰于变量，而synchronized可以修饰方法以及代码块。 多线程访问volatile不会发生堵塞，而synchronized会出现堵塞。 volatile只能保证数据的可见性，但不能保证原子性；而synchronized可以保证原子性，也可间接保证可见性，因为它会将私有内存和公共内存中的数据做同步 volatile解决的是变量在多个线程之间的可见性，而synchronized解决的是多个线程之间访问资源的同步性。 1.5 ThreadLocal Threadlocal提供了get和set的访问器，为每个使用它的线程维护一份单独的拷贝。所以get返回的都是当前线程设置的最新值。 ThreadLocal在内部维护了一个ThreadMap用来映射线程的独有变量。 1.6 Future+callable 所谓异步调用其实就是实现一个可无需等待被调用函数的返回值而让操作继续运行的方法。在 Java 语言中，简单的讲就是另启一个线程来完成调用中的部分计算，使调用继续运行或返回，而不需要等待计算结果。但调用者仍需要取线程的计算结果。 CompletableFuture: supplyAsync：执行一个异步请求，并返回一个future thenApply：对结果应用一个函数 thenCompose：对结果调用函数并执行返回的future handle：处理结果或错误 thenAccept： 类似于 thenApply, 不过结果为 void whenComplete：类似于 handle, 不过结果为 void thenRun：执行 Runnable, 结果为 void thenCombine:执行两个动作并用给定函数组合结果 thenAcceptBoth:与 thenCombine 类似， 不过结果为 void runAfterBoth:两个都完成后执行_able applyToEither:得到其中一个的结果时， 传入给定的函数 acceptEither:与 applyToEither 类似， 不过结果为 void runAfterEither:其中一个完成后执行 runnable static allOf:所有给定的 future 都完成后完成，结果为 void static anyOf:任意给定的 future 完成后则完成，结果为 void 1.7 SynchronousQueue（同步队列） 同步队列是一种将生产者与消费者线程配对的机制。当一个线程调用 SynchronousQueue 的 put 方法时，它会阻塞直到另一个线程调用 take 方法为止， 反之亦然。 与 Exchanger 的情 况不同， 数据仅仅沿一个方向传递，从生产者到消费者。 即使 SynchronousQueue 类实现了 BlockingQueue 接口， 概念上讲， 它依然不是一个队 列。它没有包含任何元素，它的 size 方法总是返回 0。 1.8 堵塞队列 用处： 对于许多线程问题， 可以通过使用一个或多个队列以优雅且安全的方式将其形式化。生产者线程向队列插人元素， 消费者线程则取出它们。使用队列，可以安全地从一个线程向另一个线程传递数据。 常用堵塞队列 ArrayBlockingQueue：构造一个带有指定容量和公平性设置的堵塞队列。该队列用循环数组实现。 LinkedBlockingQueue/LinkedBlockingDeque：构造一个无上限的堵塞队列或双向队列，用链表实现。 DelayQueue：构造一个包含 Delayed 元素的无界的阻塞时间有限的阻塞队列。只有那些延迟已经超过时间的元素可以从队列中移出。 PriorityBlockingQueue：构造一个无边界阻塞优先队列，用堆实现。 ConcurrentLinkedQueue：构造一个可以被多线程安全访问的无边界非阻塞的队列。 ConcurrentSkipListSet：构造一个可以被多线程安全访问的有序集。第一个构造器要求元素实现 Comparable 接口。 1.9 CountDownLatch闭锁 确保一个计算不被执行，直到它需要的资源初始化。 确保一个服务不会开始，直到它依赖的其他服务都已经开始。 等待，直到活动的所有部分都为继续处理做好充分准备。 CountDownLatch是一个灵活的闭锁实现。允许一个或多个线程等待一个事件集的发生。闭锁状态包括一个计数器，初始化为一个整数。 用来表现需要等待的事件数。countDown方法针对计数器做减操作，表示一个事件已经发生了，而await方法等待计数器达到零，此时所有需要等待的事件都已经发生。如果计数器入口时值为非零，await会一直堵塞直到计数器为零，或者等待线程中断以及超时。 1.10 CyclicBarrier同步屏障 类似于闭锁。与闭锁不同之处在于，所有的线程必须同时到达关卡点，才能继续处理。 闭锁等待的是事件；而同步屏障等待的是其他的线程。 常用示例比如：可将一个任务分割成多个子部分，然后再整合。 1.11 Semaphore计数信号量 用来控制能够同时访问某特定资源的活动的数量。 计数信号量可以用来实现资源池或者给一个容器限定边界。 一个Semaphore管理一个有效的许可，许可的除湿量通过构造函数传递给semaphore活动能够获得许可（只要还有剩余许可），并在使用之后释放许可，如果没有可用的许可，则acquire会被堵塞，直到有可用的为止。 常见的信号量使用即数据库连接池。 1.12 Exchanger交换器 当两个线程在同一个数据缓冲区的两个实例上工作的时候， 就可以使用交换器 ( Exchanger) 典型的情况是， 一个线程向缓冲区填人数据， 另一个线程消耗这些数据。当它们都完成以后，相互交换缓冲区。 1.13 线程池相关参数 核心ThreadPoolExecutor参数： corePoolSize：指定线程池中的线程数量 maximumPoolSize：指定了线程池中的最大线程数量。 keepAliveTime：当线程池线程数量超过corePoolSize，多余的空闲线程的存活时间，即超过corePoolSizde的空闲线程，在多长时间内会被销毁。 unit：keepAliveTime的单位 workQueue：任务队列，被提交但未被执行的任务。 threadFactory:线程工厂，用于创建线程，一般用默认的既可 handler：拒绝策略。当任务太多来不及处理，如何拒绝任务。 workQueue说明： 是一个BlockingQueue接口对象。仅用于存放Runnable对象。 直接提交队列：该功能由SynchronousQueue对象提供。SynchronousQueue没有容量，每一个插入操作都要等待一个相应的删除操作，同理删除。如果使用SynchronizeQueue，则提交的任务不会被真实的保存，而总是将新任务提交给线程执行，如果没有空闲的线程，则尝试创建新的线程，如果线程已经达到最大值，则执行拒绝策略。 有界的任务队列：ArrayBlockQueue实现。当有新的任务需要执行，如果线程池的实际线程数小于corePoolSize，则会优先创建新的线程，若大于corePoolSize，则会将新任务加入等待队列，若等待队列已满，无法加入，则在总线程不大于maximumPoolSize的前提下，创建新的线程执行任务。若大于maximumPoolSize，则执行拒绝策略。 无界的任务队列：LinkBlockQueue类实现。与有界队列相比，除非系统资源耗尽，否则无界队列不存在任务入队失败的情况，当有新的任务到来，系统的线程数小于corePoolSize，线程池会生成新的线程执行任务，当系统的线程数达到corePoolSize，就不会继续增加了。若后续仍有新的任务加入，而有没有空闲的线程资源，则任务直接进入队列等待。若任务创建和处理的速度差异很大，无界队列会保持快速增长，直到耗尽系统内存。 优先任务队列：PriorityBlockQueue实现。可以控制任务执行的先后顺序。它是一个特殊的无界队列。 拒绝策略说明：（可扩展RejectedExecutionHandler接口） AbprtPolicy：该策略会直接抛出异常，阻止系统工作 CallRunsPolicy：只要线程池未关闭，该策略直接在调用者线程中，运行当前被丢弃的任务。显然这样做不会真的丢弃任务，但是，任务提交线程的性能极有可能急剧下降。 DiscardOldestPolicy：该策略将丢弃最老的一个请求，也就是即将被执行的一个任务，并尝试再次提交当前任务。 DiscardPolicy：该策略默默丢弃无法处理的任务，不予任何处理。 扩展：ThreadPoolExecutor提供了beforeExecute(),afterExecute和terminated()三个方法用来对线程池进行控制 "},"THREAD/GUVVA.html":{"url":"THREAD/GUVVA.html","title":"guava框架","keywords":"","body":"guava框架 1.1 限流算法 漏桶算法：利用一个缓冲区，当有请求进入系统时，无论请求的速率如何，都先在缓冲区保存，然后以固定的流速流出缓存区进行处理。漏桶算法的特点是无论外部请求压力如何，漏桶算法总以固定的流速处理数据。漏桶的容器和流出速率是该算法的两个重要参数。 令牌桶算法，是一种反向的漏桶算法。在令牌桶算法中，桶中存放的不再是请求，而是令牌，处理程序只有拿到令牌，才能对请求进行处理。如果没有令牌，那么处理程序要么丢弃请求，要么等待可用的令牌。为了限制流速，该算法在每个单位时间产生一定量的令牌存入桶中。（RateLimiter采用的就是此算法）。 "},"THREAD/DISRUPTOR .html":{"url":"THREAD/DISRUPTOR .html","title":"Disruptor框架","keywords":"","body":"Disruptor框架 1.1 消费者模式 Disruptor消费者获取缓冲区数据的几种策略 BlockWaitStrategy：默认策略。使用BlockWaitStrategy和使用BlockQueue是非常类似的。都是用锁和条件进行数据的监控和线程的唤醒。因为涉及到线程的切换，BlockWaitStrategy策略最节省CPU，但是在高并发下他是性能表现最糟糕的一种等待的略。 SleepingWaitStrategy：这种策略对CPU的消耗和BlockWaitStrategy类似。他会在循环中不断等待数据。它会进行自旋等待，如果不成功，则使用Thread.yield()方法让出CPU ,并最终使用LockSupport.parkNanos（1）进行线程休眠，以确保不占用太多的CPU数据。因此，这种策略对于数据处理可能晖产生比较高的平均延时。他适合对延时要求不是特别高的场合，好处是它对生产者线程的影响最小，典型的应用场景是异步日志。 YieldWaitStrategy：个策略用于低延时场合。消费者线程会不断循环监控缓冲区的变化，在循环内部，它会使用Thread.yield（）方法让出CPU给别的线程执行时间。如果你需要一个高性能的系统，并且对延时有较为严格的要求，则可以考虑这种策略。使用这种策略，相当于消费者线程变成了一个内部执行了Thread.yield（）方法的死循环。因此，你最好有多于消费者线程数量的逻辑CPU数量（这里的逻辑CPU指的是“双核四线程”的四线程，否则整个应用程序都会收到影响）。 BusySpinWaitStrategy：消费者线程会尽最大努力疯狂监控缓冲区的变化。因此，它会吃掉所有的CPU资源。只有对延迟非常苛刻的场合可以考虑使用它。因为使用它等于开启了一个死循环监控，所以你的物理CPU数量必须大于消费者的线程数。 "},"java8/BASE.html":{"url":"java8/BASE.html","title":"java8新特性","keywords":"","body":"java8新特性 1.1 lambda 常用函数接口： Predicate T->boolean 接收T类型的对象并返回boolean值 IntPredicate 接收Integer类型对象 LongPredicate 接收Long类型对象 DoublePredicate 接收Double类型对象 Consumer T->void 接收T类型的对象并进行处理 IntConsumer 接收Integer类型对象 LongConsumer 接收Long类型对象 LongConsumer 接收Double类型对象 Function T->R 接收T类型对象，进行处理后变成R类型对象 IntFunction 接收Integer类型对象，进行处理后变成R类型对象 IntToDoubleFunction IntToLongFunction LongFunction LongToDoubleFunction LongToIntFunction DoubleFunction ToIntFunction 接收T类型对象，返回Integer ToDoubleFunction ToLongFunction Supplier ()->T Supplier主要是用来创建对象的。可以将耗时操作放在get里，在程序中，传递是Supplier对象，只有真正调用get方法时才执行运算，这就是所谓的惰性求值。 BooleanSupplier IntSupplier LongSupplier DoubleSupplier UnaryOperator T->T 接收T类型对象，经过处理后返回T类型对象 IntUnaryOperator LongUnaryOperator DoubleUnaryOperator BinaryOperator (T,T)->T 对两个T类型对象进行处理返回T类型对象 IntBinaryOperator LongBinaryOperator DoubleBinaryOperator BiPredicate (L,R)->boolean 对两个不同类型对象进行处理，返回boolean类型 BiConsumer (T,U)->void 对两个对象进行处理 ObjIntConsumer ObjLongConsumer objDoubleConsumer BiFunction (T,U)->R 对T,U两个类型的对象进行处理并返回R类型数据 ToIntBiFunction ToLongBiFunction ToDoubleBiFunction 1.2 Stream 定义：从支持数据处理操作的源生成元素的序列。 详细定义： 元素序列：就像集合一样，流也提供了一个接口，可以访问特定元素类型的一组有序值。集合讲的是数据，流讲的是计算。 源：流会使用一个提供数据的源，如集合，数组或输入/输出资源。 数据处理操作：流的数据处理功能类似于数据库的操作，以及函数式编程语言中的常用操作。流操作可以顺序执行，也可并行执行。 流操作特点： 流水线：很多操作本身会返回一个流，这样多个操作就可以链接起来，形成一个大的流水线。流水线的操作可以看做对数据源进行数据库式查询。 内部迭代：与使用迭代显式迭代的集合不同，流的迭代操作是在背后进行的。 流只能遍历一次。 1.3.2.1 stream常用方法 (数值类型的流：IntStream，LongStream) map：转换流，将一种类型的流转换为另外一种流。 filter：过滤流，过滤流中的元素。 flapMap：拆解流，将流中每一个元素拆解成一个流。 sorted：对流进行排序。 limit:元素不能超过指定长度。短路操作。 distinct:去重。返回一个元素各异（根据流生成的hashcode和equal的方法实现）的的流。 skip(n):返回一个扔掉前n个元素的流。 flatMap:将一个流中的每个值都转换成另一个流，然后将所有的流链接起来成为一个流，见simpleStreamTest2。 anyMatch：流中是否有一个元素能匹配给定的谓词。 allMatch：类似anyMatch，查看流流中元素是否都能匹配给定的谓词。 noneMatch：allMatch相反。 findAny:返回当前元素的任意元素。 findFirst：查找第一个元素。 reduce：数值计算。 "},"SERVLET/BASE.html":{"url":"SERVLET/BASE.html","title":"servlet总结","keywords":"","body":"servlet总结 "},"SPRING/BASE.html":{"url":"SPRING/BASE.html","title":"Spring总结","keywords":"","body":"Spring总结 "},"ALGORITHM/BASE.html":{"url":"ALGORITHM/BASE.html","title":"算法总结","keywords":"","body":"算法总结 "},"DESIGN/BASE.html":{"url":"DESIGN/BASE.html","title":"设计模式","keywords":"","body":"设计模式 "},"CONTAINER/BASE.html":{"url":"CONTAINER/BASE.html","title":"LINUX+DOCKER","keywords":"","body":"LINUX+DOCKER "}}