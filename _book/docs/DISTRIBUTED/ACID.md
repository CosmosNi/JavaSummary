# 分布式事务

###### 1.1 ACID传统数据库

- Atomicity原子性：一个事务中所有操作都必须全部完成，要么全部不完成。 
- Consistency一致性：在事务开始或结束时，数据库应该在一致状态。 
- Isolation隔离层： 并发的事务是相互隔离的，一个事务的执行不能被其他事务干扰。
  - Read Uncommitted：允许脏读取。可以读取其他事务未提交的数据。
  - Read Committed：只允许获取已经被提交的数据。
  - Repeatable Read：可重复读取。就是保证在事务处理过程中，多次读取同一数据时，其值和事务开始时刻是一致的。可能会出现幻影数据，即在不同时间段读取同一数据项，可能出现不一致的结果。
  - Serializable：要求所有事务都被串行执行。
- Durability. 一旦事务完成，就不能返回。
  

###### 1.2 CAP理论

- Partition tolerance:分区容错。分布式系统在遇到任何网络分区故障的时候，仍然需要能够保证对外提供满足一致性和可用性的服务，除非整个网络环境都发生了故障。
- Consistency ：一致性。是指数据在多个副本之间能够保持一致的特性。
- Availability ：可用性。系统提供的服务必须一直处于可用的状态，对于用户的每一个操作请求总是能够在有限的时间内返回结果。

在分布式系统中，只可能满足CP或者AP。如果要保证一致性，那么写的操作必然需要加锁，这样就不满足可用性。如果要保证可用性，那么在通信失败的情况下，无法满足一致性。所以在分布式系统下，需要对一致性和可用性进行取舍。



###### 1.3  BASE理论

- 基本可用（Basically Available）：是指在分布式系统出现故障的时候，允许损失部分可用性，即保证核心可用。（服务降级）。
  - 响应时间上的损失
  - 功能上的损失

- 软状态（Soft State）：允许系统存在中间状态，该中间状态不会影响系统整体可用性。即允许系统在不同节点的数据副本之间进行同步的过程存在延时。

- 最终一致性：是指系统中的所有数据副本经过一段时间后，最终能达到一致的状态。

  
  
  实际工程实践的变种
  
  - 因果一致性：A更新完数据项通知B，那么B对于该数据项进行更新操作时，必须基于A更新后的最新值。
  - 读己之所写：进程A更新一个数据项后，它总能访问到更新过的最新值。
  - 会话一致性：将系统数据的访问过程框在一个会话中，保证在同一个有效的会话中实现“读己之所写”的一致性。
  - 单调读一致性：一个进程从系统中读取出一个数据项的某个值后，那么系统对于该进程后续的任何数据访问都不应该返回旧的值。
  - 单调写一致性：一个系统需要能够保证来自同一进程的写操作被顺序的执行
  
  

###### 1.4 两阶段提交（2pc）

第一阶段：准备阶段。

- 协调者节点向所有参与者节点询问是否可以执行提交操作(vote)，并开始等待各参与者节点的响应。
- 参与者节点执行询问发起为止的所有事务操作，并将Undo信息和Redo信息写入日志。（注意：若成功这里其实每个参与者已经执行了事务操作）
- 各参与者节点响应协调者节点发起的询问。如果参与者节点的事务操作实际执行成功，则它返回一个”同意”消息；如果参与者节点的事务操作实际执行失败，则它返回一个”中止”消息。

第二阶段：提交阶段。

如果协调者收到了参与者的失败消息或者超时，直接给每个参与者发送回滚(Rollback)消息；否则，发送提交(Commit)消息；参与者根据协调者的指令执行提交或者回滚操作，释放所有事务处理过程中使用的锁资源。(注意:必须在最后阶段释放锁资源)

- 当协调者节点从所有参与者节点获得的相应消息都为”同意”时:
   1）协调者节点向所有参与者节点发出”正式提交(commit)”的请求。
   2）参与者节点正式完成操作，并释放在整个事务期间内占用的资源。
   3）参与者节点向协调者节点发送”完成”消息。
   4）协调者节点受到所有参与者节点反馈的”完成”消息后，完成事务。

- 当任一参与者节点在第一阶段返回的响应消息为”中止”或协调者节点在第一阶段的询问超时之前无法获取所有参与者节点的响应消息时:
   1）协调者节点向所有参与者节点发出”回滚操作(rollback)”的请求。
   2）参与者节点利用之前写入的Undo信息执行回滚，并释放在整个事务期间内占用的资源。
   3）参与者节点向协调者节点发送”回滚完成”消息。
   4）协调者节点受到所有参与者节点反馈的”回滚完成”消息后，取消事务。



缺点：

1. 同步阻塞问题。执行过程中，所有参与节点都是事务阻塞型的。当参与者占有公共资源时，其他第三方节点访问公共资源不得不处于阻塞状态。

2. 单点故障。由于协调者的重要性，一旦协调者发生故障。参与者会一直阻塞下去。尤其在第二阶段，协调者发生故障，那么所有的参与者还都处于锁定事务资源的状态中，而无法继续完成事务操作。

3. 数据不一致。在二阶段提交的阶段二中，当协调者向参与者发送commit请求之后，发生了局部网络异常或者在发送commit请求过程中协调者发生了故障，这回导致只有一部分参与者接受到了commit请求。而在这部分参与者接到commit请求之后就会执行commit操作。但是其他部分未接到commit请求的机器则无法执行事务提交。于是整个分布式系统便出现了数据部一致性的现象。

4. 协调者再发出commit消息之后宕机，而唯一接收到这条消息的参与者同时也宕机了。那么即使协调者通过选举协议产生了新的协调者，这条事务的状态也是不确定的，没人知道事务是否被已经提交。

   

###### 1.5 三阶段提交（3pc）

在二阶段的基础上：

- 引入超时机制。同时在协调者和参与者中都引入超时机制。
- 在第一阶段和第二阶段中插入一个准备阶段。保证了在最后提交阶段之前各参与节点的状态是一致的。

1. CanCommit阶段

协调者向参与者发送commit请求，参与者如果可以提交就返回成功响应，否则返回失败响应。

- 事务询问 协调者向参与者发送CanCommit请求。询问是否可以执行事务提交操作。然后开始等待参与者的响应。
- 响应反馈 参与者接到CanCommit请求之后，正常情况下，如果其自身认为可以顺利执行事务，则返回Yes响应，并进入预备状态。否则反馈No。

2. PreCommit阶段

   协调者根据参与者的反应情况来决定是否可以记性事务的PreCommit操作。

- 发送预提交请求 协调者向参与者发送PreCommit请求，并进入Prepared阶段。

- 事务预提交 参与者接收到PreCommit请求后，会执行事务操作，并将undo和redo信息记录到事务日志中。

- 响应反馈 如果参与者成功的执行了事务操作，则返回ACK响应，同时开始等待最终指令。

  

  假如有任何一个参与者向协调者发送了No响应，或者等待超时之后，协调者都没有接到参与者的响应，那么就执行事务的中断。

- 发送中断请求 协调者向所有参与者发送abort请求。
- 中断事务 参与者收到来自协调者的abort请求之后（或超时之后，仍未收到协调者的请求），执行事务的中断。



3. doCommit阶段

   执行提交

   1. 发送提交请求 协调接收到参与者发送的ACK响应，那么他将从预提交状态进入到提交状态。并向所有参与者发送doCommit请求。

   2. 事务提交 参与者接收到doCommit请求之后，执行正式的事务提交。并在完成事务提交之后释放所有事务资源。

   3. 响应反馈 事务提交完之后，向协调者发送Ack响应。

   4. 完成事务 协调者接收到所有参与者的ack响应之后，完成事务。

      

   中断事务 （协调者没有接收到参与者发送的ACK响应）

   1. 发送中断请求 协调者向所有参与者发送abort请求

   2. 事务回滚 参与者接收到abort请求之后，利用其在阶段二记录的undo信息来执行事务的回滚操作，并在完成回滚之后释放所有的事务资源。

   3. 反馈结果 参与者完成事务回滚之后，向协调者发送ACK消息

   4. 中断事务 协调者接收到参与者反馈的ACK消息之后，执行事务的中断

      

      注：在doCommit阶段，如果参与者无法及时接收到来自协调者的doCommit或者rebort请求时，会在等待超时之后，会继续进行事务的提交。

      

   

- 发送提交请求 协调接收到参与者发送的ACK响应，那么他将从预提交状态进入到提交状态。并向所有参与者发送doCommit请求。

- 事务提交 参与者接收到doCommit请求之后，执行正式的事务提交。并在完成事务提交之后释放所有事务资源。

- 响应反馈 事务提交完之后，向协调者发送Ack响应。

- 完成事务 协调者接收到所有参与者的ack响应之后，完成事务。

  

  中断事务

  1.发送中断请求 协调者向所有参与者发送abort请求

  2.事务回滚 参与者接收到abort请求之后，利用其在阶段二记录的undo信息来执行事务的回滚操作，并在完成回滚之后释放所有的事务资源。

  3.反馈结果 参与者完成事务回滚之后，向协调者发送ACK消息

  4.中断事务 协调者接收到参与者反馈的ACK消息之后，执行事务的中断。
   在doCommit阶段，如果参与者无法及时接收到来自协调者的doCommit或者rebort请求时，会在等待超时之后，会继续进行事务的提交。



###### 1.6 Paxos算法



