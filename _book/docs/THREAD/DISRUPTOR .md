# Disruptor框架

###### 1.1 消费者模式

Disruptor消费者获取缓冲区数据的几种策略

- BlockWaitStrategy：默认策略。使用BlockWaitStrategy和使用BlockQueue是非常类似的。都是用锁和条件进行数据的监控和线程的唤醒。因为涉及到线程的切换，BlockWaitStrategy策略最节省CPU，但是在高并发下他是性能表现最糟糕的一种等待的略。
- SleepingWaitStrategy：这种策略对CPU的消耗和BlockWaitStrategy类似。他会在循环中不断等待数据。它会进行自旋等待，如果不成功，则使用Thread.yield()方法让出CPU ,并最终使用LockSupport.parkNanos（1）进行线程休眠，以确保不占用太多的CPU数据。因此，这种策略对于数据处理可能晖产生比较高的平均延时。他适合对延时要求不是特别高的场合，好处是它对生产者线程的影响最小，典型的应用场景是异步日志。
- YieldWaitStrategy：个策略用于低延时场合。消费者线程会不断循环监控缓冲区的变化，在循环内部，它会使用Thread.yield（）方法让出CPU给别的线程执行时间。如果你需要一个高性能的系统，并且对延时有较为严格的要求，则可以考虑这种策略。使用这种策略，相当于消费者线程变成了一个内部执行了Thread.yield（）方法的死循环。因此，你最好有多于消费者线程数量的逻辑CPU数量（这里的逻辑CPU指的是“双核四线程”的四线程，否则整个应用程序都会收到影响）。
- BusySpinWaitStrategy：消费者线程会尽最大努力疯狂监控缓冲区的变化。因此，它会吃掉所有的CPU资源。只有对延迟非常苛刻的场合可以考虑使用它。因为使用它等于开启了一个死循环监控，所以你的物理CPU数量必须大于消费者的线程数。