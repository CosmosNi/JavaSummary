{"./":{"url":"./","title":"前言","keywords":"","body":"前言 "},"JDK/BASE.html":{"url":"JDK/BASE.html","title":"java基础总结","keywords":"","body":"java基础总结 1.1 对象的概念 万物皆对象 程序是一组对象，通过信息传递告知彼此该做什么。 每个对象都有自己的存储空间，可容纳其他对象。 每个对象都有一个类型。每个对象都是某个类的实例。 同一类的对象都能接口相同的类型。 1.3 抽象类 抽象方法：只有声明，没有具体的实现。 如果有一个类含有抽象方法，则这个类抽象类，需由abstract修饰。 特点： 抽象方法必须是public或者protected 抽象类不能实例化 如果子类不是不是抽象类，则必须实现父类的抽象方法 1.3 接口 接口中定义的变量被隐式指定为public static final。 接口中所有的方法不能有具体的实现。在java8中，可用default关键字在接口中实现默认方法。 1.4 接口与抽象类的区别 抽象类中的成员变量可以是各种类型的，而接口中的变量是public static final 接口不能有静态代码块以及静态方法，而抽象方法可以 一个类只能实现一个抽象类，但是一个类可以实现多个接口。 抽象类是对事物的抽象，接口是对行为的抽象 1.5 重写equal()方法的注意点 自反性：对于任何非空引用，x.equals(x)应该返回true 对称性：对于任何引用x和y，如果x.equals(y)返回为true，那么y.equals(x)也应该返回true 传递性：对于任何引用，x，y和z，如果x.equals(y)返回为true，那么y.equals(x)也应该返回true 一致性：如果x和y引用的对象没有发生变化，返回调用x.equals(y)应该返回相同的结果 对于任何非空引用x，x.equals(null)应该返回false 1.6 对象序列化 对象序列化是以特殊的文件格式存储对象数据的。 1.7 类的加载 Java默认提供的三个ClassLoader： BootStrap ClassLoader：称为启动类加载器，是Java类加载层次中最顶层的类加载器，负责加载JDK中的核心类库 Extension ClassLoader：称为扩展类加载器，负责加载Java的扩展类库，默认加载JAVA_HOME/jre/lib/ext/目下的所有jar。 App ClassLoader：称为系统类加载器，负责加载应用程序classpath目录下的所有jar和class文件。 ClassLoader使用的是双亲委托模型来搜索类的（避免重复加载），从上至下搜索。每个ClassLoader实例都有一个父类加载器的引用。 JVM在判定两个class是否相同时，不仅要判断两个类名是否相同，而且要判断是否由同一个类加载器实例加载的。 "},"JVM/BASE.html":{"url":"JVM/BASE.html","title":"JVM虚拟机","keywords":"","body":"JVM虚拟机 "},"THREAD/BASE.html":{"url":"THREAD/BASE.html","title":"并发编程相关知识点","keywords":"","body":"并发编程相关知识点 1.1 线程的状态 New（新创建）：新创建一个新的线程对象对象后，在调用他的start（）方法，系统会为此线程分配CPU资源，使其处于Runnable（可运行状态），这是一个准备运行的阶段。如果线程抢占到CPU资源，此线程就处于Running（运行）状态。 Runnable（可运行） Runnable状态和Running状态可相互切换，因为有可能线程运行一段时间后，有其他高优先级的线程抢占了CPU资源，这时Running状态变成了Runnable状态。 线程进入Runnable状态大体分为如下几种情况： 调用sleep（）方法后经过的时间超过了指定的休眠时间 线程调用的堵塞IO已经返回，堵塞方法执行完毕 线程成功地获取了试图同步的监视器 线程处于等待某个通知，其他线程发出了通知。 处于挂起状态的线程调用了resume回复方法。 Blocked（被堵塞） 例如遇到一个IO操作，此时CPU处于空闲状态，可能会转而把CPU时间片分配给其他的线程，这是也可以成为“暂停”状态。 线程调用sleep（）方法，主动放弃占用的处理器资源。 线程调用了堵塞式IO方法，在该方法返回前，该线程堵塞 线程试图获得一个同步监视器，但该同步监视器正被其他线程所持有。 线程等待某个通知。 程序调用了suspend方法将该线程挂起。此方法容易导致死锁，尽量避免使用该方法。 run（）：运行结束进入销毁阶段，整个线程执行完毕。 join（）：使所属线程对象x正常执行run（）方法中的任务，而使当前线程z无限期堵塞，等待线程x销毁后再继续执行线程z后面的代码。join具有使线程排队运行的作用，有些类似同步的运行效果。join与synchronized的区别是：join在内部使用wait方法进行等待，而synchronized使用的“对象监视器”原理做同步。 Waiting（等待） Timed（waiting） Terminated（被终止） "},"THREAD/JUC.html":{"url":"THREAD/JUC.html","title":"jdk内置JUC组件","keywords":"","body":"jdk内置JUC组件 1.1 Lock+Condition Lock作用: 锁用来保护代码片段，任何时刻只能有一个线程执行被保护的代码。 锁可以管理试图进入被保护代码段的线程。 锁可以拥有一个或多个相关的条件对象。 每个条件对象管理那些已经进入被保护的代码段但还不能运行的线程。 公平与非公平锁: 公平锁表示线程获取锁的顺序是按照线程加锁的顺序来分配的，即先来先得的FIFO先进先出顺序。而非公平锁是一种获取锁的抢占机制，是随机获得锁的，和公平锁不一样的就是先来的不一定先得到锁，这个方式肯呢过造成某些线程一直拿不到锁，结果也就是不公平的了。 ReentrantLock (默认非公平锁): 重入锁（ReentrantLock）是一种递归无阻塞的同步机制。 它有一个与锁相关的获取计数器，如果拥有锁的某个线程再次得到锁，那么获取计数器就加1，然后锁需要被释放两次才能获得真正释放。这模仿了 synchronized 的语义；如果线程进入由线程已经拥有的监控器保护的 synchronized 块，就允许线程继续进行，当线程退出第二个（或者后续） synchronized 块的时候，不释放锁，只有线程退出它进入的监控器保护的第一个 synchronized 块时，才释放锁。 常用方法： lock()： 如果该锁没有被另一个线程保持，则获取该锁并立即返回，将锁的保持计数设置为 1。 如果当前线程已经保持该锁，则将保持计数加 1，并且该方法立即返回。 如果该锁被另一个线程保持，则出于线程调度的目的，禁用当前线程，并且在获得锁之前，该线程将一直处于休眠状态，此时锁保持计数被设置为 1 lockInterruptibly() 如果当前线程未被中断，则获取锁。 如果该锁没有被另一个线程保持，则获取该锁并立即返回，将锁的保持计数设置为 1。 如果当前线程已经保持此锁，则将保持计数加 1，并且该方法立即返回。 如果锁被另一个线程保持，则出于线程调度目的，禁用当前线程，并且在发生以下两种情况之一以前，该线程将一直处于休眠状态(锁由当前线程获得；或者 其他某个线程中断当前线程。 ) 如果当前线程获得该锁，则将锁保持计数设置为 1。 此方法是一个显式中断点，所以要优先考虑响应中断，而不是响应锁的普通获取或重入获取。 tryLock():仅在调用时锁未被另一个线程保持的情况下，才获取该锁。 如果该锁没有被另一个线程保持，并且立即返回 true 值，则将锁的保持计数设置为 1。即使已将此锁设置为使用公平排序策略，但是调用 tryLock() 仍将 立即获取锁（如果有可用的），而不管其他线程当前是否正在等待该锁。在某些情况下，此“闯入”行为可能很有用，即使它会打破公平性也如此。如果希望遵守此锁的公平设置，则使用 tryLock(0, TimeUnit.SECONDS) ，它几乎是等效的（也检测中断）。 如果当前线程已经保持此锁，则将保持计数加 1，该方法将返回 true。 如果锁被另一个线程保持，则此方法将立即返回 false 值。 1.2 synchroized 相关定义： 调用关键字synchroized生命的方法一定是排队运行的 避免数据出现交叉的情况，使用synchroized关键词进行同步 关键词synchroized拥有锁重入的功能 ，也就是在使用synchroized时，当一个线程得到一个对象锁后，在此请求此对象锁时是可以再次得到该对象锁的。 当一个线程执行的代码出现异常时，其所持有的锁会自动释放。 同步不可以被继承。 synchroized同步块 锁非this对象相比synchroized（this）更加灵活，当一个方法中有多个同步块时，不用竞争this对象锁。 关于synchroized（非this对象x）的写法是将x对象本身作为\"对象监视器\"，有如下三个结论： 当多个线程同时执行synchroized（X）{}同步代码块时呈同步效果。 当其他线程执行x对象中synchroized同步方法时呈同步效果。 当其他线程执行x对象方法中的synchroized（this）代码块时也呈现同步效果。 如果其他线程调用不加synchroized关键字的方法时，还是异步调用。 synchroized关键字加到非static静态方法是给对象上锁，而教导static方法上则是对Class类加锁。 对于String对象，不要用作对象锁。String a=\"A\",String b=\"A\"，a==b，导致线程会使用同一个对象锁 在设计程序时，要避免双方互相持有对方锁的情况，会导致死锁。 "},"THREAD/GUVVA.html":{"url":"THREAD/GUVVA.html","title":"guava框架","keywords":"","body":"guava框架 "},"THREAD/DISRUPTOR .html":{"url":"THREAD/DISRUPTOR .html","title":"Disruptor框架","keywords":"","body":"Disruptor框架 "},"java8/BASE.html":{"url":"java8/BASE.html","title":"java8新特性","keywords":"","body":"java8新特性 "},"SERVLET/BASE.html":{"url":"SERVLET/BASE.html","title":"servlet总结","keywords":"","body":"servlet总结 "},"SPRING/BASE.html":{"url":"SPRING/BASE.html","title":"Spring总结","keywords":"","body":"Spring总结 "},"ALGORITHM/BASE.html":{"url":"ALGORITHM/BASE.html","title":"算法总结","keywords":"","body":"算法总结 "},"DESIGN/BASE.html":{"url":"DESIGN/BASE.html","title":"设计模式","keywords":"","body":"设计模式 "},"CONTAINER/BASE.html":{"url":"CONTAINER/BASE.html","title":"LINUX+DOCKER","keywords":"","body":"LINUX+DOCKER "}}